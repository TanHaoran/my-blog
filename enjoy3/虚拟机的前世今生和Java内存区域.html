<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>虚拟机的前世今生和Java内存区域 | 林山夕风</title>
    <meta name="description" content="林山夕风的博客,md文档,技术博客">
    <meta name="generator" content="VuePress 1.3.0">
    <link rel="icon" href="/my-blog/avatar.jpg">
  <script>
                var _hmt = _hmt || [];
                (function() {
                    var hm = document.createElement("script");
                    hm.src = "https://hm.baidu.com/hm.js?68e7a949df184c1e4c82b115461e51e0";
                    var s = document.getElementsByTagName("script")[0];
                    s.parentNode.insertBefore(hm, s);
                })();
            </script>
    
    <link rel="preload" href="/my-blog/assets/css/0.styles.67b6080f.css" as="style"><link rel="preload" href="/my-blog/assets/js/app.11c55fdf.js" as="script"><link rel="preload" href="/my-blog/assets/js/2.f643b0a2.js" as="script"><link rel="preload" href="/my-blog/assets/js/46.0f46c833.js" as="script"><link rel="preload" href="/my-blog/assets/js/4.fd36f240.js" as="script"><link rel="preload" href="/my-blog/assets/js/5.628d6842.js" as="script"><link rel="prefetch" href="/my-blog/assets/js/10.f4eaa613.js"><link rel="prefetch" href="/my-blog/assets/js/100.07e38629.js"><link rel="prefetch" href="/my-blog/assets/js/101.dcfe2bf2.js"><link rel="prefetch" href="/my-blog/assets/js/102.209999b3.js"><link rel="prefetch" href="/my-blog/assets/js/103.a9a85d34.js"><link rel="prefetch" href="/my-blog/assets/js/104.fdefe1dc.js"><link rel="prefetch" href="/my-blog/assets/js/105.e4b5d0af.js"><link rel="prefetch" href="/my-blog/assets/js/106.cf83f84b.js"><link rel="prefetch" href="/my-blog/assets/js/107.848b42d5.js"><link rel="prefetch" href="/my-blog/assets/js/108.351fb64c.js"><link rel="prefetch" href="/my-blog/assets/js/109.4b9111f6.js"><link rel="prefetch" href="/my-blog/assets/js/11.5d5723d1.js"><link rel="prefetch" href="/my-blog/assets/js/110.7f24fb6a.js"><link rel="prefetch" href="/my-blog/assets/js/111.28300395.js"><link rel="prefetch" href="/my-blog/assets/js/112.839af357.js"><link rel="prefetch" href="/my-blog/assets/js/113.67de001a.js"><link rel="prefetch" href="/my-blog/assets/js/114.408ea2f6.js"><link rel="prefetch" href="/my-blog/assets/js/115.34a1d81a.js"><link rel="prefetch" href="/my-blog/assets/js/116.f510ca2c.js"><link rel="prefetch" href="/my-blog/assets/js/117.24ddf316.js"><link rel="prefetch" href="/my-blog/assets/js/12.06fcb150.js"><link rel="prefetch" href="/my-blog/assets/js/13.c441de9d.js"><link rel="prefetch" href="/my-blog/assets/js/14.ca26e948.js"><link rel="prefetch" href="/my-blog/assets/js/15.e7761bd0.js"><link rel="prefetch" href="/my-blog/assets/js/16.5be4d33f.js"><link rel="prefetch" href="/my-blog/assets/js/17.4426a95c.js"><link rel="prefetch" href="/my-blog/assets/js/18.7d974f8d.js"><link rel="prefetch" href="/my-blog/assets/js/19.775995bc.js"><link rel="prefetch" href="/my-blog/assets/js/20.71c35e12.js"><link rel="prefetch" href="/my-blog/assets/js/21.741a18a7.js"><link rel="prefetch" href="/my-blog/assets/js/22.819a7e85.js"><link rel="prefetch" href="/my-blog/assets/js/23.f9133433.js"><link rel="prefetch" href="/my-blog/assets/js/24.86a7d541.js"><link rel="prefetch" href="/my-blog/assets/js/25.0aa2d6ab.js"><link rel="prefetch" href="/my-blog/assets/js/26.3e55392e.js"><link rel="prefetch" href="/my-blog/assets/js/27.ae2e0581.js"><link rel="prefetch" href="/my-blog/assets/js/28.aaa62b88.js"><link rel="prefetch" href="/my-blog/assets/js/29.55007ae9.js"><link rel="prefetch" href="/my-blog/assets/js/3.57915124.js"><link rel="prefetch" href="/my-blog/assets/js/30.63aac023.js"><link rel="prefetch" href="/my-blog/assets/js/31.d5607214.js"><link rel="prefetch" href="/my-blog/assets/js/32.a7ae912b.js"><link rel="prefetch" href="/my-blog/assets/js/33.58fcbfa4.js"><link rel="prefetch" href="/my-blog/assets/js/34.8538d781.js"><link rel="prefetch" href="/my-blog/assets/js/35.14a82428.js"><link rel="prefetch" href="/my-blog/assets/js/36.2ad806dd.js"><link rel="prefetch" href="/my-blog/assets/js/37.207a29ce.js"><link rel="prefetch" href="/my-blog/assets/js/38.57c0d12e.js"><link rel="prefetch" href="/my-blog/assets/js/39.83aff8a9.js"><link rel="prefetch" href="/my-blog/assets/js/40.bcbcfd03.js"><link rel="prefetch" href="/my-blog/assets/js/41.d0a94dfd.js"><link rel="prefetch" href="/my-blog/assets/js/42.f6011b50.js"><link rel="prefetch" href="/my-blog/assets/js/43.efd29b4c.js"><link rel="prefetch" href="/my-blog/assets/js/44.e5c9709c.js"><link rel="prefetch" href="/my-blog/assets/js/45.7656da3c.js"><link rel="prefetch" href="/my-blog/assets/js/47.40ce4540.js"><link rel="prefetch" href="/my-blog/assets/js/48.3db9c583.js"><link rel="prefetch" href="/my-blog/assets/js/49.53285ac3.js"><link rel="prefetch" href="/my-blog/assets/js/50.4db56f99.js"><link rel="prefetch" href="/my-blog/assets/js/51.188f8c4f.js"><link rel="prefetch" href="/my-blog/assets/js/52.95be221e.js"><link rel="prefetch" href="/my-blog/assets/js/53.276e1791.js"><link rel="prefetch" href="/my-blog/assets/js/54.2fd73796.js"><link rel="prefetch" href="/my-blog/assets/js/55.c90a5bd8.js"><link rel="prefetch" href="/my-blog/assets/js/56.406f89df.js"><link rel="prefetch" href="/my-blog/assets/js/57.811f05ab.js"><link rel="prefetch" href="/my-blog/assets/js/58.e2896a54.js"><link rel="prefetch" href="/my-blog/assets/js/59.e5f3be54.js"><link rel="prefetch" href="/my-blog/assets/js/6.8ba90f8e.js"><link rel="prefetch" href="/my-blog/assets/js/60.e4b67c15.js"><link rel="prefetch" href="/my-blog/assets/js/61.7b772903.js"><link rel="prefetch" href="/my-blog/assets/js/62.bbe4352b.js"><link rel="prefetch" href="/my-blog/assets/js/63.e350ef3b.js"><link rel="prefetch" href="/my-blog/assets/js/64.7b6ca2f6.js"><link rel="prefetch" href="/my-blog/assets/js/65.76baf7fa.js"><link rel="prefetch" href="/my-blog/assets/js/66.ff801cea.js"><link rel="prefetch" href="/my-blog/assets/js/67.ee30cd5b.js"><link rel="prefetch" href="/my-blog/assets/js/68.0f4c1ce2.js"><link rel="prefetch" href="/my-blog/assets/js/69.111ce4de.js"><link rel="prefetch" href="/my-blog/assets/js/7.55078740.js"><link rel="prefetch" href="/my-blog/assets/js/70.46f8b5e8.js"><link rel="prefetch" href="/my-blog/assets/js/71.675e279c.js"><link rel="prefetch" href="/my-blog/assets/js/72.c419d947.js"><link rel="prefetch" href="/my-blog/assets/js/73.6eb4799a.js"><link rel="prefetch" href="/my-blog/assets/js/74.18229d2e.js"><link rel="prefetch" href="/my-blog/assets/js/75.46c8298d.js"><link rel="prefetch" href="/my-blog/assets/js/76.c966d3c5.js"><link rel="prefetch" href="/my-blog/assets/js/77.b31efc9c.js"><link rel="prefetch" href="/my-blog/assets/js/78.f7e57735.js"><link rel="prefetch" href="/my-blog/assets/js/79.e056b5a5.js"><link rel="prefetch" href="/my-blog/assets/js/8.ddecccf2.js"><link rel="prefetch" href="/my-blog/assets/js/80.0fc539d1.js"><link rel="prefetch" href="/my-blog/assets/js/81.2b7f0d10.js"><link rel="prefetch" href="/my-blog/assets/js/82.d3e4b716.js"><link rel="prefetch" href="/my-blog/assets/js/83.3073a1d2.js"><link rel="prefetch" href="/my-blog/assets/js/84.d231aeff.js"><link rel="prefetch" href="/my-blog/assets/js/85.7daed020.js"><link rel="prefetch" href="/my-blog/assets/js/86.0c8d8d8e.js"><link rel="prefetch" href="/my-blog/assets/js/87.c4ba5f03.js"><link rel="prefetch" href="/my-blog/assets/js/88.9a4e0ef6.js"><link rel="prefetch" href="/my-blog/assets/js/89.b7bca56b.js"><link rel="prefetch" href="/my-blog/assets/js/9.7463f385.js"><link rel="prefetch" href="/my-blog/assets/js/90.49ec4345.js"><link rel="prefetch" href="/my-blog/assets/js/91.84cb7a66.js"><link rel="prefetch" href="/my-blog/assets/js/92.cb5ea946.js"><link rel="prefetch" href="/my-blog/assets/js/93.05e2ac79.js"><link rel="prefetch" href="/my-blog/assets/js/94.e60969c0.js"><link rel="prefetch" href="/my-blog/assets/js/95.688af442.js"><link rel="prefetch" href="/my-blog/assets/js/96.aba3a873.js"><link rel="prefetch" href="/my-blog/assets/js/97.ca8196eb.js"><link rel="prefetch" href="/my-blog/assets/js/98.071b3a0f.js"><link rel="prefetch" href="/my-blog/assets/js/99.eca50447.js">
    <link rel="stylesheet" href="/my-blog/assets/css/0.styles.67b6080f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/my-blog/" class="home-link router-link-active"><!----> <span class="site-name">林山夕风</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/my-blog/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="基础教程" class="dropdown-title"><span class="title">基础教程</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/my-blog/frontend/" class="nav-link">
  前端
</a></li><li class="dropdown-item"><!----> <a href="/my-blog/backend/" class="nav-link">
  后端
</a></li><li class="dropdown-item"><!----> <a href="/my-blog/enjoy3/" class="nav-link router-link-active">
  进阶
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据结构与算法" class="dropdown-title"><span class="title">数据结构与算法</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/my-blog/structure/" class="nav-link">
  数据结构
</a></li><li class="dropdown-item"><!----> <a href="/my-blog/algorithm/" class="nav-link">
  算法
</a></li></ul></div></div><div class="nav-item"><a href="/my-blog/leetcode/" class="nav-link">
  LeetCode题解
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="设计思想" class="dropdown-title"><span class="title">设计思想</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/my-blog/principle/" class="nav-link">
  设计原则
</a></li><li class="dropdown-item"><!----> <a href="/my-blog/pattern/" class="nav-link">
  设计模式
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="读书笔记" class="dropdown-title"><span class="title">读书笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/my-blog/thinking_in_java/" class="nav-link">
  Java编程思想
</a></li><li class="dropdown-item"><!----> <a href="/my-blog/refactoring_improving_the_design_of_existing_code/" class="nav-link">
  重构改善既有代码的设计
</a></li></ul></div></div><div class="nav-item"><a href="/my-blog/project/" class="nav-link">
  项目实战
</a></div><div class="nav-item"><a href="/my-blog/article/" class="nav-link">
  零散文章
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="代码管理" class="dropdown-title"><span class="title">代码管理</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://gitee.com/doomthr" target="_blank" rel="noopener noreferrer" class="nav-link external">
  码云
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://github.com/TanHaoran" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/my-blog/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="基础教程" class="dropdown-title"><span class="title">基础教程</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/my-blog/frontend/" class="nav-link">
  前端
</a></li><li class="dropdown-item"><!----> <a href="/my-blog/backend/" class="nav-link">
  后端
</a></li><li class="dropdown-item"><!----> <a href="/my-blog/enjoy3/" class="nav-link router-link-active">
  进阶
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据结构与算法" class="dropdown-title"><span class="title">数据结构与算法</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/my-blog/structure/" class="nav-link">
  数据结构
</a></li><li class="dropdown-item"><!----> <a href="/my-blog/algorithm/" class="nav-link">
  算法
</a></li></ul></div></div><div class="nav-item"><a href="/my-blog/leetcode/" class="nav-link">
  LeetCode题解
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="设计思想" class="dropdown-title"><span class="title">设计思想</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/my-blog/principle/" class="nav-link">
  设计原则
</a></li><li class="dropdown-item"><!----> <a href="/my-blog/pattern/" class="nav-link">
  设计模式
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="读书笔记" class="dropdown-title"><span class="title">读书笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/my-blog/thinking_in_java/" class="nav-link">
  Java编程思想
</a></li><li class="dropdown-item"><!----> <a href="/my-blog/refactoring_improving_the_design_of_existing_code/" class="nav-link">
  重构改善既有代码的设计
</a></li></ul></div></div><div class="nav-item"><a href="/my-blog/project/" class="nav-link">
  项目实战
</a></div><div class="nav-item"><a href="/my-blog/article/" class="nav-link">
  零散文章
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="代码管理" class="dropdown-title"><span class="title">代码管理</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://gitee.com/doomthr" target="_blank" rel="noopener noreferrer" class="nav-link external">
  码云
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://github.com/TanHaoran" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>进阶</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/my-blog/enjoy3/虚拟机的前世今生和Java内存区域.html" class="active sidebar-link">虚拟机的前世今生和Java内存区域</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/my-blog/enjoy3/虚拟机的前世今生和Java内存区域.html#一、jvm-基础知识" class="sidebar-link">一、JVM 基础知识</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/my-blog/enjoy3/虚拟机的前世今生和Java内存区域.html#_1、jvm-从编译到执行" class="sidebar-link">1、JVM 从编译到执行</a></li><li class="sidebar-sub-header"><a href="/my-blog/enjoy3/虚拟机的前世今生和Java内存区域.html#_2、从跨平台到跨语言" class="sidebar-link">2、从跨平台到跨语言</a></li><li class="sidebar-sub-header"><a href="/my-blog/enjoy3/虚拟机的前世今生和Java内存区域.html#_3、jvm-的发展" class="sidebar-link">3、JVM 的发展</a></li></ul></li><li class="sidebar-sub-header"><a href="/my-blog/enjoy3/虚拟机的前世今生和Java内存区域.html#二、jvm-整体知识模块" class="sidebar-link">二、JVM 整体知识模块</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/my-blog/enjoy3/虚拟机的前世今生和Java内存区域.html#_1、jvm-的内存区域" class="sidebar-link">1、JVM 的内存区域</a></li><li class="sidebar-sub-header"><a href="/my-blog/enjoy3/虚拟机的前世今生和Java内存区域.html#_2、运行时数据区及-jvm-的整体内存结构" class="sidebar-link">2、运行时数据区及 JVM 的整体内存结构</a></li></ul></li></ul></li><li><a href="/my-blog/enjoy3/深入理解JVM的内存区域.html" class="sidebar-link">深入理解JVM的内存区域</a></li><li><a href="/my-blog/enjoy3/玩转JVM中的对象及引用.html" class="sidebar-link">玩转JVM中的对象及引用</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="虚拟机的前世今生和java内存区域"><a href="#虚拟机的前世今生和java内存区域" class="header-anchor">#</a> 虚拟机的前世今生和Java内存区域</h1> <div><span id="/my-blog/enjoy3/虚拟机的前世今生和Java内存区域.html" data-flag-title="虚拟机的前世今生和Java内存区域" class="leancloud_visitors read-count"><em class="post-meta-item-text">阅读量 </em> <i class="leancloud-visitors-count">loading</i></span> <div class="clear-both"></div></div> <h2 id="一、jvm-基础知识"><a href="#一、jvm-基础知识" class="header-anchor">#</a> 一、JVM 基础知识</h2> <h3 id="_1、jvm-从编译到执行"><a href="#_1、jvm-从编译到执行" class="header-anchor">#</a> 1、JVM 从编译到执行</h3> <h4 id="_1-java-程序的执行过程"><a href="#_1-java-程序的执行过程" class="header-anchor">#</a> (1) Java 程序的执行过程</h4> <p>一个 <code>Java</code> 程序，首先经过 <code>javac</code> 编译成 <code>.class</code> 文件，然后 <code>JVM</code> 将其加载到方法区，执行引擎将会执行这些字节码。执行时，会翻译成操作系统相关的函数。<code>JVM</code> 作为 <code>.class</code> 文件的翻译存在，输入字节码，调用操作系统函数。</p> <p>过程如下： <code>Java</code> 文件 -&gt; 编译器 -&gt; 字节码 -&gt; <code>JVM</code> -&gt; 机器码。
<code>JVM</code> 全称 <code>Java Virtual Machine</code>，也就是我们耳熟能详的 <code>Java 虚拟机</code>。它能识别 <code>.class</code> 后缀的文件，并且能够解析它的指令，最终调用操作系统上的函数，完成我们想要的操作。</p> <h4 id="_2-jvm、jre、jdk-的关系"><a href="#_2-jvm、jre、jdk-的关系" class="header-anchor">#</a> (2) JVM、JRE、JDK 的关系</h4> <p><code>JVM</code> 只是一个翻译，把 <code>class</code> 翻译成机器识别的代码，但是需要注意，<code>JVM</code> 不会自己生成代码，需要大家编写代码，同时需要很多依赖类库，这个时候就需要用到 <code>JRE</code>。</p> <p><code>JRE</code> 是什么，它除了包含 <code>JVM</code> 之外，提供了很多的类库（就是我们说的 <code>jar</code> 包，它可以提供一些即插即用的功能，比如读取或者操作文件，连接网络，使用 <code>I/O</code> 等等之类的）这些东西就是 <code>JRE</code> 提供的基础类库。<code>JVM</code> 标准加上实现的一大堆基础类库，就组成了 <code>Java</code> 的运行时环境，也就是我们常说的 <code>JRE</code>（<code>Java Runtime Environment</code>）。</p> <p>但对于程序员来说，<code>JRE</code> 还不够。我写完要编译代码，还需要调试代码，还需要打包代码、有时候还需要反编译代码。所以我们会使用 <code>JDK</code>，因为 <code>JDK</code> 还提供了一些非常好用的小工具，比如 <code>javac</code>（编译代码）、<code>java</code>、<code>jar</code> （打包代码）、<code>javap</code>（反编译&lt;反汇编&gt;）等。这个就是 <code>JDK</code>。</p> <p>具体可以文档可以通过官网去下载：<a href="https://www.oracle.com/java/technologies/javase-jdk8-doc-downloads.html" target="_blank" rel="noopener noreferrer">https://www.oracle.com/java/technologies/javase-jdk8-doc-downloads.html<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><code>JVM</code> 的作用是：从软件层面屏蔽不同操作系统在底层硬件和指令的不同。这个就是我们在宏观方面对<code>JVM</code> 的一个认识。</p> <p>同时 <code>JVM</code> 是一个虚拟化的操作系统，类似于 <code>Linux</code> 或者 <code>Windows</code> 的操作系统，只是它架在操作系统上，接收字节码也就是 <code>class</code>，把字节码翻译成操作系统上的机器码且进行执行。</p> <h3 id="_2、从跨平台到跨语言"><a href="#_2、从跨平台到跨语言" class="header-anchor">#</a> 2、从跨平台到跨语言</h3> <ul><li>跨平台</li></ul> <p>我们写的一个类，在不同的操作系统上（<code>Linux</code>、<code>Windows</code>、<code>MacOS</code> 等平台）执行，效果是一样，这个就是 <code>JVM</code> 的跨平台性。</p> <p>为了实现跨平台型，不同操作系统有对应的 <code>JDK</code> 的版本：</p> <p><a href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html" target="_blank" rel="noopener noreferrer">https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <ul><li>跨语言（语言无关性）</li></ul> <p><code>JVM</code> 只识别字节码，所以 <code>JVM</code> 其实跟语言是解耦的，也就是没有直接关联，<code>JVM</code> 运行不是翻译 <code>Java</code> 文件，而是识别 <code>class</code> 文件，这个一般称之为字节码。还有像 <code>Groovy</code>、<code>Kotlin</code>、<code>Scala</code> 等等语言，它们其实也是编译成字节码，所以它们也可以在 <code>JVM</code> 上面跑，这个就是 <code>JVM</code> 的跨语言特征。<code>Java</code> 的跨语言性一定程度上奠定了非常强大的 <code>Java</code> 语言生态圈。</p> <h3 id="_3、jvm-的发展"><a href="#_3、jvm-的发展" class="header-anchor">#</a> 3、JVM 的发展</h3> <h4 id="常见的-jvm-实现"><a href="#常见的-jvm-实现" class="header-anchor">#</a> 常见的 JVM 实现</h4> <ul><li>Hotspot</li></ul> <p>目前使用的最多的 <code>JVM</code>。在命令行输入 <code>java –version</code>。它会输出你现在使用的虚拟机的名字、版本等信息、执行模式。</p> <p>我的信息如下：</p> <div class="language-cmd line-numbers-mode"><pre class="language-text"><code>java version &quot;1.8.0_191&quot;
Java(TM) SE Runtime Environment (build 1.8.0_191-b12)
Java HotSpot(TM) 64-Bit Server VM (build 25.191-b12, mixed mode)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>Jrocket</li></ul> <p>原来属于 <code>BEA</code> 公司，曾号称世界上最快的 <code>JVM</code>，后被 <code>Oracle</code> 公司收购，合并于 <code>Hotspot</code>。</p> <ul><li>J9</li></ul> <p><code>IBM</code> 有自己的 <code>JVM</code> 实现，它的名字叫做 <code>J9</code>。 主要是用在 <code>IBM</code> 产品（<code>IBM WebSphere</code> 和 <code>IBM</code> 的 <code>AIX</code> 平台上）</p> <ul><li>TaobaoVM</li></ul> <p>只有一定体量、一定规模的厂商才会开发自己的虚拟机，比如淘宝有自己的 <code>JVM</code>,它实际上是 <code>Hotspot</code> 的定制版，专门为淘宝准备的，阿里、天猫都是用的这款虚拟机。</p> <ul><li>LiquidVM</li></ul> <p>它是一个针对硬件的虚拟机，它下面是没有操作系统的（不是 <code>Linux</code> 也不是 <code>windows</code>）,下面直接就是硬件，运行效率比较高。</p> <ul><li>zing</li></ul> <p>它属于 <code>zual</code> 这家公司，非常牛，是一个商业产品，很贵！它的垃圾回收速度非常快（1 毫秒之内），是业界标杆。它的一个垃圾回收的算法后来被 <code>Hotspot</code> 吸收才有了现在的 <code>ZGC</code>。</p> <h2 id="二、jvm-整体知识模块"><a href="#二、jvm-整体知识模块" class="header-anchor">#</a> 二、JVM 整体知识模块</h2> <p><code>JVM</code> 能涉及非常庞大的一块知识体系，比如内存结构、垃圾回收、类加载、性能调优、<code>JVM</code> 自身优化技术、执行引擎、类文件结构、监控工具等。</p> <p>但是在所有的知识体系中，都或多或少跟内存结构有一定的关系：比如垃圾回收回收的就是内存、类加载加载到的地方也是内存、性能优化也涉及到内存优化、执行引擎与内存密不可分、类文件结构与内存的设计有关系，监控工具也会监控内存。所以内存结构处于 <code>JVM</code> 中核心位置。也是属于我们入门 <code>JVM</code> 学习的最好的选择。</p> <p>同时 <code>JVM</code> 是一个虚拟化的操作系统，所以除了要虚拟指令之外，最重要的一个事情就是需要虚拟化内存，这个虚拟化内存就是 <code>JVM</code> 的内存区域。</p> <h3 id="_1、jvm-的内存区域"><a href="#_1、jvm-的内存区域" class="header-anchor">#</a> 1、JVM 的内存区域</h3> <h4 id="_1-运行时数据区域"><a href="#_1-运行时数据区域" class="header-anchor">#</a> (1) 运行时数据区域</h4> <ul><li>运行时数据区的定义</li></ul> <p><code>JVM</code> 在执行 <code>Java</code> 程序的过程中会把它所管理的内存划分为若干个不同的数据区域</p> <p><code>Java</code> 引以为豪的就是它的自动内存管理机制。相比于 <code>C++</code> 的手动内存管理、复杂难以理解的指针等，<code>Java</code> 程序写起来就方便的多。</p> <p>所以要深入理解 <code>JVM</code> 必须理解内存虚拟化的概念。</p> <p>在 <code>JVM</code> 中，<code>JVM</code> 内存主要分为 <code>堆</code>、<code>方法区</code>、<code>虚拟机栈</code>、<code>程序计数器</code> 和 <code>本地方法栈</code> 等。</p> <p>同时按照与线程的关系也可以这么划分区域：</p> <p><code>线程私有区域</code>：一个线程拥有单独的一份内存区域。</p> <p><code>线程共享区域</code>：被所有线程共享，且只有一份。</p> <p><code>直接内存</code>：这个虽然不是运行时数据区的一部分，但是会被频繁使用。你可以理解成没有被虚拟机化的操作系统上的其他内存（比如操作系统上有 8G 内存，被 <code>JVM</code> 虚拟化了 3G，那么还剩余 5G， <code>JVM</code> 是借助一些工具使用这 5G 内存的，这个内存部分称之为直接内存）</p> <p><img src="https://yjtravel-public.oss-cn-beijing.aliyuncs.com/my-blog/enjoy3/jvm1.png" alt="内存划分"></p> <h4 id="_2-java-方法的运行与虚拟机栈"><a href="#_2-java-方法的运行与虚拟机栈" class="header-anchor">#</a> (2) JAVA 方法的运行与虚拟机栈</h4> <p><code>虚拟机栈</code> 是线程运行 <code>Java 方法</code> 所需的数据、指令、返回地址。其实在我们实际的代码中，一个线程是可以运行多个方法的。例如这段方法：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MethodAndStack</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>这段代码很简单，就是起一个 <code>main()</code> 方法，在 <code>main()</code> 方法运行中调用 <code>a()</code> 方法，<code>a()</code> 方法中调用 <code>b()</code> 方法，<code>b()</code> 方法中运行 <code>c()</code> 方法。</p> <p>把代码跑起来，<code>线程1</code> 来运行这段代码， <code>线程1</code> 跑起来，就会有一个对应的 <code>虚拟机栈</code>，同时在执行每个方法的时候都会打包成一个 <code>栈帧</code>。</p> <p>比如 <code>main()</code> 开始运行，打包一个 <code>栈帧</code> 送入到 <code>虚拟机栈</code>，然后 <code>a()</code> 方法入栈，接着 <code>b()</code> 方法入栈，最后 <code>c()</code> 方法入栈。<code>c()</code> 方法运行完了，<code>c()</code> 方法出栈，接着 <code>b()</code> 方法运行完了，<code>b()</code> 方法出栈、接着 <code>a()</code> 方法运行完了，<code>a()</code> 方法出栈，最后 <code>main()</code> 方法运行完了，<code>main()</code> 方法这个 <code>栈帧</code> 就出栈了。</p> <p>这个就是 <code>Java 方法</code> 运行对 <code>虚拟机栈</code> 的一个影响。<code>虚拟机栈</code> 就是用来存储线程运行方法中的数据的。而每一个方法对应一个 <code>栈帧</code>。</p> <h3 id="_2、运行时数据区及-jvm-的整体内存结构"><a href="#_2、运行时数据区及-jvm-的整体内存结构" class="header-anchor">#</a> 2、运行时数据区及 JVM 的整体内存结构</h3> <h4 id="_1-虚拟机栈"><a href="#_1-虚拟机栈" class="header-anchor">#</a> (1) 虚拟机栈</h4> <ul><li>栈的数据结构</li></ul> <p>先进后出(<code>FILO</code>)的数据结构</p> <ul><li>虚拟机栈的作用</li></ul> <p>在 <code>JVM</code> 运行过程中存储当前线程运行方法所需的数据、指令、返回地址。</p> <ul><li>虚拟机栈是基于线程的</li></ul> <p>哪怕你只有一个 <code>main()</code> 方法，也是以线程的方式运行的。在线程的生命周期中，参与计算的数据会频繁地入栈和出栈，栈的生命周期是和线程一样的。</p> <ul><li>虚拟机栈的大小</li></ul> <p>缺省为 1M，可用参数 <code>–Xss</code> 调整大小，例如 <code>-Xss256k</code>。参数官方文档（<code>JDK1.8</code>）：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html" target="_blank" rel="noopener noreferrer">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h5 id="xss-大小"><a href="#xss-大小" class="header-anchor">#</a> -Xss 大小</h5> <p>设置线程堆栈大小（以字节码为单位）。附加字母 <code>k</code> 或 <code>K</code> 表示 <code>KB</code>，<code>m</code> 或 <code>M</code> 表示 <code>MB</code>，<code>g</code> 或 <code>G</code> 表示 <code>GB</code>。默认值取决于平台。</p> <ul><li>Linux / ARM（32位）：320KB</li> <li>Linux / i386（32位）：320KB</li> <li>Linux / x64（64位）：1024KB</li> <li>OS X （64位）：1024KB</li> <li>Oracle Solaris / i386（32位）：320KB</li> <li>Oracle Solaris / x64位（64位）：1024KB</li></ul> <h5 id="栈帧"><a href="#栈帧" class="header-anchor">#</a> 栈帧</h5> <p>在每个 <code>Java 方法</code> 被调用的时候，都会创建一个 <code>栈帧</code>，并入栈。一旦方法完成相应的调用，则出栈。</p> <p><code>栈帧</code> 大体都包含四个区域：(<code>局部变量表</code>、<code>操作数栈</code>、<code>动态连接</code>、<code>返回地址</code>)</p> <ul><li>局部变量表</li></ul> <p>顾名思义就是局部变量的表，用于存放局部变量（方法中的变量）。首先它是一个 32位 的长度，主要存放 <code>Java</code> 的 <code>八大基础数据类型</code>，一般 32位 就可以存放下，如果是 64位 的就使用高低位占用两个也可以存放下，如果是局部的一些对象，比如 <code>Object</code> 对象，我们只需要存放它的一个引用地址即可。</p> <ul><li>操作数栈</li></ul> <p>存放 <code>Java 方法</code> 执行的操作数的，它就是一个栈，先进后出的栈结构，操作数栈，就是用来操作的，操作的的元素可以是任意的 <code>Java 数据类型</code>，所以一个方法刚刚开始的时候，这个方法的操作数栈就是空的。</p> <p>操作数栈本质上是 <code>JVM</code> 执行引擎的一个工作区，也就是方法在执行，才会对操作数栈进行操作，如果代码不不执行，操作数栈其实就是空的。</p> <ul><li>动态连接</li></ul> <p><code>Java</code> 语言特性多态，后续会结合 <code>class</code> 与 <code>执行引擎</code> 一起详细说明。</p> <ul><li>返回地址</li></ul> <p>正常返回：调用程序计数器中的地址作为返回；异常：通过异常处理器表（非栈帧中的）来确定</p> <p>同时，<code>虚拟机栈</code> 这个内存也不是无限大，它有大小限制，默认情况下是 1M。</p> <p>我们不断的往 <code>虚拟机栈</code> 中入 <code>栈帧</code>，但是就是不出栈的话，那么这个虚拟机栈就会爆掉。</p> <p>例如下面这段代码就会发生栈溢出：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StackError</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><div class="language-console line-numbers-mode"><pre class="language-text"><code>Exception in thread &quot;main&quot; java.lang.StackOverflowError
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h4 id="_2-程序计数器"><a href="#_2-程序计数器" class="header-anchor">#</a> (2) 程序计数器</h4> <p>较小的内存空间，当前线程执行的字节码的行号指示器；各线程之间独立存储，互不影响。</p> <p>程序计数器是一块很小的内存空间，主要用来记录各个线程执行的字节码的地址，例如，分支、循环、跳转、异常、线程恢复等都依赖于计数器。</p> <p>由于 <code>Java</code> 是多线程语言，当执行的线程数量超过 <code>CPU</code> 核数时，线程之间会根据时间片轮询争夺 <code>CPU</code> 资源。如果一个线程的时间片用完了，或者是其它原因导致这个线程的 <code>CPU</code> 资源被提前抢夺，那么这个退出的线程就需要单独的一个程序计数器，来记录下一条运行的指令。</p> <p>因为 <code>JVM</code> 内部有完整的指令与执行的一套流程，所以在运行 <code>Java 方法</code> 的时候需要使用 <code>程序计数器</code> （记录字节码执行的地址或行号），如果是遇到本地方法（<code>native 方法</code>），这个方法不是 <code>JVM</code> 来具体执行，所以此时 <code>程序计数器</code> 不需要记录，这个是因为在操作系统层面也有一个 <code>程序计数器</code>，这个会记录本地代码的执行的地址，所以在执行 <code>native 方法</code> 时，<code>JVM</code> 中程序计数器的值为空(<code>Undefined</code>)。</p> <p>另外程序计数器也是 <code>JVM</code> 中唯一不会 <code>OOM</code>(<code>OutOfMemory</code>)的内存区域。</p> <h5 id="栈帧执行对内存区域的影响"><a href="#栈帧执行对内存区域的影响" class="header-anchor">#</a> 栈帧执行对内存区域的影响</h5> <p>对 <code>class</code> 进行反汇编 <code>javap –c XXXX.class</code>。</p> <p>字节码助记码解释地址：<a href="https://cloud.tencent.com/developer/article/1333540" target="_blank" rel="noopener noreferrer">https://cloud.tencent.com/developer/article/1333540<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>一个线程中的虚拟机栈和程序计数器：</p> <p><img src="https://yjtravel-public.oss-cn-beijing.aliyuncs.com/my-blog/enjoy3/jvm2.png" alt="一个线程中的虚拟机栈和程序计数器"></p> <p>在 <code>JVM</code> 中，基于解释执行的这种方式是基于栈的引擎，这个说的栈，就是操作数栈。</p> <h4 id="_3-本地方法栈"><a href="#_3-本地方法栈" class="header-anchor">#</a> (3) 本地方法栈</h4> <p>本地方法栈跟 <code>Java 虚拟机栈</code> 的功能类似，<code>Java 虚拟机栈</code> 用于管理 <code>Java 函数</code> 的调用，而本地方法栈则用于管理 <code>本地方法</code> 的调用。但本地方法并不是用 <code>Java</code> 实现的，而是由 <code>C</code> 语言实现的(比如 <code>Object</code> 的 <code>hashcode()</code> 方法)。</p> <p>本地方法栈是和虚拟机栈非常相似的一个区域，它服务的对象是 <code>native 方法</code>。你甚至可以认为虚拟机栈和本地方法栈是同一个区域。</p> <p>虚拟机规范无强制规定，各版本虚拟机自由实现，<code>HotSpot</code> 直接把 <code>本地方法栈</code> 和 <code>虚拟机栈</code> 合二为一。</p> <h4 id="_4-方法区"><a href="#_4-方法区" class="header-anchor">#</a> (4) 方法区</h4> <p>方法区主要是用来存放已被虚拟机加载的类相关信息，包括类信息、静态变量、常量、运行时常量池、字符串常量池等。</p> <p>方法区是 <code>JVM</code> 对内存的“逻辑划分”，在 <code>JDK1.7</code> 及之前很多开发者都习惯将 <code>方法区</code> 称为 <code>永久代</code> ，是因为在 <code>HotSpot</code> 虚拟机中，设计人员使用了 <code>永久代</code> 来实现了 <code>JVM</code> 规范的 <code>方法区</code>。在 <code>JDK1.8</code> 及以后使用了 <code>元空间</code> 来实现方法区。</p> <p><code>JVM</code> 在执行某个类的时候，必须先加载。在加载类（加载、验证、准备、解析、初始化）的时候，<code>JVM</code> 会先加载 <code>class</code> 文件，而在 <code>class</code> 文件中除了有类的版本、字段、方法和接口等描述信息外，还有一项信息是 <code>常量池</code>(<code>Constant Pool Table</code>)，用于存放编译期间生成的各种 <code>字面量</code> 和 <code>符号引用</code>。</p> <h5 id="字面量"><a href="#字面量" class="header-anchor">#</a> 字面量</h5> <p><code>字面量</code> 包括字符串（<code>String a = &quot;b&quot;</code>）、基本类型的常量（<code>final</code> 修饰的变量），<code>符号引用</code> 则包括类和方法的全限定名（例如 <code>String</code> 这个类，它的全限定名就是 <code>Java.lang.String</code>）、字段的名称和描述符以及方法的名称和描述符。</p> <h5 id="符号引用"><a href="#符号引用" class="header-anchor">#</a> 符号引用</h5> <p>一个 <code>Java 类</code>（假设为 <code>People</code> 类）被编译成一个 <code>class</code> 文件时，如果 <code>People</code> 类引用了 <code>Tool</code> 类，但是在编译时 <code>People</code> 类并不知道引用类的实际内存地址，因此只能使用符号引用来代替。</p> <p>而在类装载器装载 <code>People</code> 类时，此时可以通过虚拟机获取 <code>Tool</code> 类的实际内存地址，因此便可以将符号 <code>org.simple.Tool</code> 替换为 <code>Tool</code> 类的实际内存地址，及直接引用地址。</p> <p>即在编译时用 <code>符号引用</code> 来代替 <code>引用类</code>，在加载时再通过虚拟机获取该引用类的实际地址。</p> <p>以一组符号来描述所引用的目标，符号可以是任何形式的 <code>字面量</code>，只要使用时能无歧义地定位到目标即可。<code>符号引用</code> 与虚拟机实现的内存布局是无关的，引用的目标不一定已经加载到内存中。</p> <h5 id="常量池与运行时常量池"><a href="#常量池与运行时常量池" class="header-anchor">#</a> 常量池与运行时常量池</h5> <p>而当类加载到内存中后，<code>JVM</code> 就会将 <code>class</code> 文件 <code>常量池</code> 中的内容存放到 <code>运行时的常量池</code> 中；在解析阶段，<code>JVM</code> 会把 <code>符号引用</code> 替换为 <code>直接引用</code>（对象的索引值）。</p> <p>例如，类中的一个字符串常量在 <code>class</code> 文件中时，存放在 <code>class</code> 文件 <code>常量池</code> 中的；在 <code>JVM</code> 加载完类之后，<code>JVM</code> 会将这个字符串常量放到 <code>运行时常量池</code> 中，并在解析阶段，指定该字符串对象的索引值。运行时常量池是全局共享的，多个类共用一个运行时常量池，<code>class</code> 文件中 <code>常量池</code> 多个相同的字符串在运行时常量池只会存在一份。</p> <p><code>常量池</code> 有很多概念，包括 <code>运行时常量池</code>、<code>class 常量池</code>、<code>字符串常量池</code>。</p> <p>虚拟机规范只规定以上区域属于 <code>方法区</code>，并没有规定虚拟机厂商的实现。</p> <p>严格来说是 <code>静态常量池</code> 和 <code>运行时常量池</code>，<code>静态常量池</code> 是存放字符串 <code>字面量</code>、<code>符号引用</code> 以及 类和方法的信息，而运行时常量池存放的是运行时一些 <code>直接引用</code>。</p> <p><code>运行时常量池</code> 是在类加载完成之后，将 <code>静态常量池</code> 中的 <code>符号引用</code> 值转存到 <code>运行时常量池</code> 中，类在解析之后，将<code>符号引用</code> 替换成 <code>直接引用</code>。</p> <p>运行时常量池在 <code>JDK1.7</code> 版本之后，就移到 <code>堆</code> 内存中了，这里指的是物理空间，而逻辑上还是属于 <code>方法区</code>（方法区是逻辑分区）。</p> <h5 id="元空间"><a href="#元空间" class="header-anchor">#</a> 元空间</h5> <p><code>方法区</code> 与 <code>堆</code> 空间类似，也是一个共享内存区，所以 <code>方法区</code> 是线程共享的。假如两个线程都试图访问 <code>方法区</code> 中的同一个类信息，而这个类还没有装入 <code>JVM</code>，那么此时就只允许一个线程去加载它，另一个线程必须等待。</p> <p>在 <code>HotSpot</code> 虚拟机、<code>Java7</code> 版本中已经将永久代的 <code>静态变量</code> 和 <code>运行时常量池</code> 转移到了 <code>堆</code> 中，其余部分则存储在 <code>JVM</code> 的非堆内存中，而 <code>Java8</code> 版本已经将 <code>方法区</code> 中实现的 <code>永久代</code> 去掉了，并用<code>元空间</code>（<code>class metadata</code>）代替了之前的 <code>永久代</code>，并且 <code>元空间</code> 的存储位置是本地内存。</p> <p>设置元空间大小参数：</p> <ul><li>jdk1.7 及以前（初始和最大值）：-XX:PermSize；-XX:MaxPermSize；</li> <li>jdk1.8 以后（初始和最大值）：-XX:MetaspaceSize； -XX:MaxMetaspaceSize</li> <li>jdk1.8 以后大小就只受本机总内存的限制（如果不设置参数的话）</li></ul> <p><code>JVM</code> 参数参考：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html" target="_blank" rel="noopener noreferrer">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><code>Java8</code> 为什么使用元空间替代永久代，这样做有什么好处呢？</p> <p>官方给出的解释是：</p> <p>移除 <code>永久代</code> 是为了融合 <code>HotSpot JVM</code> 与 <code>JRockit VM</code> 而做出的努力，因为 <code>JRockit</code> 没有永久代，所以不需要配置永久代
。<code>永久代</code> 内存经常不够用或发生内存溢出，抛出异常 <code>java.lang.OutOfMemoryError: PermGen</code>。这是因为在 <code>JDK1.7</code> 版本中，指定的 <code>PermGen</code> 区大小为 8M，由于 <code>PermGen</code> 中类的元数据信息在每次 <code>FullGC</code> 的时候都可能被收集，回收率都偏低，成绩很难令人满意；还有为 <code>PermGen</code> 分配多大的空间很难确定，<code>PermSize</code> 的大小依赖于很多因素，比如，<code>JVM</code> 加载的 <code>class</code> 总数、<code>常量池</code> 的大小和方法的大小等。</p> <h4 id="_5-堆"><a href="#_5-堆" class="header-anchor">#</a> (5) 堆</h4> <p>堆是 <code>JVM</code> 上最大的内存区域，我们申请的几乎所有的对象，都是在这里存储的。我们常说的垃圾回收，操作的对象就是堆。</p> <p>堆空间一般是程序启动时，就申请了，但是并不一定会全部使用。堆一般设置成可伸缩的。</p> <p>随着对象的频繁创建，堆空间占用的越来越多，就需要不定期的对不再使用的对象进行回收。这个在 <code>Java</code> 中，就叫作 <code>GC</code>（<code>Garbage Collection</code>）。</p> <p>那一个对象创建的时候，到底是在堆上分配，还是在栈上分配呢？这和两个方面有关：对象的类型和在 <code>Java</code> 类中存在的位置。</p> <p><code>Java</code> 的对象可以分为 <code>基本数据类型</code> 和 <code>普通对象</code>。</p> <p>对于普通对象来说，<code>JVM</code> 会首先在堆上创建对象，然后在其他地方使用的其实是它的引用。比如，把这个引用保存在虚拟机栈的局部变量表中。</p> <p>对于基本数据类型来说（<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>float</code>、<code>double</code>、<code>char</code>)，有两种情况。</p> <p>当你在方法体内声明了基本数据类型的对象，它就会在栈上直接分配。其他情况，都是在堆上分配。</p> <p>设置堆大小参数：</p> <ul><li>-Xms：堆的最小值；</li> <li>-Xmx：堆的最大值；</li> <li>-Xmn：新生代的大小；</li> <li>-XX:NewSize；新生代最小值；</li> <li>-XX:MaxNewSize：新生代最大值；</li></ul> <p>例如 <code>-Xmx256m</code> ，设置堆最大值为 256m</p> <h4 id="_6-直接内存（堆外内存）"><a href="#_6-直接内存（堆外内存）" class="header-anchor">#</a> (6) 直接内存（堆外内存）</h4> <p>直接内存有一种更加科学的叫法，<code>堆外内存</code>。</p> <p><code>JVM</code> 在运行时，会从操作系统申请大块的堆内存，进行数据的存储；同时还有虚拟机栈、本地方法栈和程序计数器，这块称之为栈区。操作系统剩余的内存也就是堆外内存。</p> <p>它不是虚拟机运行时数据区的一部分，也不是 <code>JVM</code> 规范中定义的内存区域；如果使用了 <code>NIO</code>，这块区域会被频繁使用，在 <code>Java 堆</code> 内可以用 <code>DirectByteBuffer</code> 对象直接引用并操作。</p> <p>这块内存不受 <code>Java 堆</code> 大小限制，但受本机总内存的限制，可以通过 <code>-XX:MaxDirectMemorySize</code> 来设置（默认与堆内存最大值一样），所以也会出现 <code>OOM</code> 异常。</p> <p>总结下：</p> <ol><li>直接内存主要是通过 <code>DirectByteBuffer</code> 申请的内存，可以使用参数 <code>MaxDirectMemorySize</code> 来限制它的大小。</li> <li>其他堆外内存，主要是指使用了 <code>Unsafe</code> 或者其他 <code>JNI</code> 手段直接直接申请的内存。堆外内存的泄漏是非常严重的，它的排查难度高、影响大，甚至会造成主机的死亡。同时，要注意 <code>Oracle</code> 之前计划在 <code>Java 9</code> 中去掉 <code>sun.misc.Unsafe</code> 的 <code>API</code>。这里删除 <code>sun.misc.Unsafe</code> 的原因之一是使 <code>Java</code> 更加安全，并且有替代方案。目前主要针对的 <code>JDK1.8</code>，<code>JDK1.9</code> 暂时不放入讨论范围中，大致知道 <code>Java</code> 的发展即可。</li></ol> <div><br> <div id="vcomments"></div></div></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2020-08-21 09:02:51（10 小时前）</span></div></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/my-blog/enjoy3/深入理解JVM的内存区域.html">
        深入理解JVM的内存区域
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/my-blog/assets/js/app.11c55fdf.js" defer></script><script src="/my-blog/assets/js/2.f643b0a2.js" defer></script><script src="/my-blog/assets/js/46.0f46c833.js" defer></script><script src="/my-blog/assets/js/4.fd36f240.js" defer></script><script src="/my-blog/assets/js/5.628d6842.js" defer></script>
  </body>
</html>
