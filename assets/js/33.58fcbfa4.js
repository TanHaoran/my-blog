(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{243:function(_,v,e){"use strict";e.r(v);var a=e(0),t=Object(a.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h1",{attrs:{id:"常见并发面试题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常见并发面试题"}},[_._v("#")]),_._v(" 常见并发面试题")]),_._v(" "),e("Counter",{attrs:{path:"backend",name:"常见并发面试题"}}),_._v(" "),e("h2",{attrs:{id:"常见面试题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常见面试题"}},[_._v("#")]),_._v(" 常见面试题")]),_._v(" "),e("h3",{attrs:{id:"_1、在-java-中守护线程和用户线程的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、在-java-中守护线程和用户线程的区别"}},[_._v("#")]),_._v(" 1、在 java 中守护线程和用户线程的区别")]),_._v(" "),e("p",[e("code",[_._v("Java")]),_._v(" 中的线程分为两种：守护线程（"),e("code",[_._v("Daemon")]),_._v("）和用户线程（"),e("code",[_._v("User")]),_._v("）。")]),_._v(" "),e("p",[_._v("任何线程都可以设置为守护线程和用户线程，通过方法 "),e("code",[_._v("Thread.setDaemon(boolean);")]),_._v(" ，"),e("code",[_._v("true")]),_._v(" 则把该线程设置为守护线程，反之则为用户线程。"),e("code",[_._v("Thread.setDaemon()")]),_._v(" 必须在 "),e("code",[_._v("Thread.start()")]),_._v(" 之前调用，否则运行时会抛出异常。")]),_._v(" "),e("p",[_._v("两者的区别：")]),_._v(" "),e("p",[_._v("唯一的区别是判断虚拟机("),e("code",[_._v("JVM")]),_._v(")何时离开，"),e("code",[_._v("Daemon")]),_._v(" 是为其他线程提供服务，如果全部的 "),e("code",[_._v("User Thread")]),_._v(" 已经结束，"),e("code",[_._v("Daemon")]),_._v(" 没有可服务的线程，"),e("code",[_._v("JVM")]),_._v(" 关闭。")]),_._v(" "),e("p",[_._v("扩展："),e("code",[_._v("Thread Dump")]),_._v(" 打印出来的线程信息，含有 "),e("code",[_._v("daemon")]),_._v(" 字样的线程即为守护进程。")]),_._v(" "),e("h2",{attrs:{id:"_2、线程与进程的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、线程与进程的区别"}},[_._v("#")]),_._v(" 2、线程与进程的区别")]),_._v(" "),e("p",[_._v("进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。")]),_._v(" "),e("p",[_._v("一个程序至少有一个进程,一个进程至少有一个线程。")]),_._v(" "),e("h2",{attrs:{id:"_3、什么是多线程中的上下文切换"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3、什么是多线程中的上下文切换"}},[_._v("#")]),_._v(" 3、什么是多线程中的上下文切换")]),_._v(" "),e("p",[_._v("多线程会共同使用一组计算机上的 "),e("code",[_._v("CPU")]),_._v("，而线程数大于给程序分配的 "),e("code",[_._v("CPU")]),_._v(" 数量时，为了让各个线程都有执行的机会，就需要轮转使用 "),e("code",[_._v("CPU")]),_._v("。不同的线程切换使用 "),e("code",[_._v("CPU")]),_._v(" 发生的切换数据等就是上下文切换。")]),_._v(" "),e("h2",{attrs:{id:"_4、死锁与活锁的区别，死锁与饥饿的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4、死锁与活锁的区别，死锁与饥饿的区别"}},[_._v("#")]),_._v(" 4、死锁与活锁的区别，死锁与饥饿的区别")]),_._v(" "),e("p",[_._v("死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。")]),_._v(" "),e("p",[_._v("产生死锁的必要条件：")]),_._v(" "),e("ul",[e("li",[_._v("互斥条件：所谓互斥就是进程在某一时间内独占资源。")]),_._v(" "),e("li",[_._v("请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。")]),_._v(" "),e("li",[_._v("不剥夺条件:进程已获得资源，在末使用完之前，不能强行剥夺。")]),_._v(" "),e("li",[_._v("循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。")])]),_._v(" "),e("p",[_._v("活锁：任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。")]),_._v(" "),e("p",[_._v("活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”，而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。")]),_._v(" "),e("p",[_._v("饥饿：一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。")]),_._v(" "),e("h2",{attrs:{id:"_5、synchronized-底层实现原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5、synchronized-底层实现原理"}},[_._v("#")]),_._v(" 5、synchronized 底层实现原理")]),_._v(" "),e("p",[e("code",[_._v("synchronized")]),_._v(" 原理：涉及两条指令："),e("code",[_._v("monitorenter")]),_._v("，"),e("code",[_._v("monitorexit")]),_._v("；再说同步方法，从同步方法反编译的结果来看，方法的同步并没有通过指令 "),e("code",[_._v("monitorenter")]),_._v(" 和 "),e("code",[_._v("monitorexit")]),_._v(" 来实现，相对于普通方法，其常量池中多了 "),e("code",[_._v("ACC_SYNCHRONIZED")]),_._v(" 标示符。")]),_._v(" "),e("p",[e("code",[_._v("JVM")]),_._v(" 就是根据该标示符来实现方法的同步的：当方法被调用时，调用指令将会检查方法的 "),e("code",[_._v("ACC_SYNCHRONIZED")]),_._v(" 访问标志是否被设置，如果设置了，执行线程将先获取 "),e("code",[_._v("monitor")]),_._v("，获取成功之后才能执行方法体，方法执行完后再释放 "),e("code",[_._v("monitor")]),_._v("。在方法执行期间，其他任何线程都无法再获得同一个 "),e("code",[_._v("monitor")]),_._v(" 对象。")]),_._v(" "),e("p",[_._v("注意，这个问题可能会接着追问，java 对象头信息，偏向锁，轻量锁，重量级锁及其他们相互间转化。")]),_._v(" "),e("h2",{attrs:{id:"_6、什么是线程组，为什么在-java-中不推荐使用？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6、什么是线程组，为什么在-java-中不推荐使用？"}},[_._v("#")]),_._v(" 6、什么是线程组，为什么在 Java 中不推荐使用？")]),_._v(" "),e("p",[e("code",[_._v("ThreadGroup")]),_._v(" 类，可以把线程归属到某一个线程组中，线程组中可以有线程对象，也可以有线程组，组中还可以有线程，这样的组织结构有点类似于树的形式。")]),_._v(" "),e("ul",[e("li",[e("p",[_._v("线程组 "),e("code",[_._v("ThreadGroup")]),_._v(" 对象中比较有用的方法是 "),e("code",[_._v("stop()")]),_._v("、"),e("code",[_._v("resume()")]),_._v("、"),e("code",[_._v("suspend()")]),_._v(" 等方法，由于这几个方法会导致线程的安全问题（主要是死锁问题），已经被官方废弃掉了，所以线程组本身的应用价值就大打折扣了。")])]),_._v(" "),e("li",[e("p",[_._v("线程组 "),e("code",[_._v("ThreadGroup")]),_._v(" 不是线程安全的，这在使用过程中获取的信息并不全是及时有效的，这就降低了它的统计使用价值。")])])]),_._v(" "),e("h2",{attrs:{id:"_7、什么是-executors-框架，为什么使用-executor-框架"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7、什么是-executors-框架，为什么使用-executor-框架"}},[_._v("#")]),_._v(" 7、什么是 Executors 框架，为什么使用 Executor 框架")]),_._v(" "),e("p",[e("code",[_._v("Executor")]),_._v(" 框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。")]),_._v(" "),e("p",[_._v("每次执行任务创建线程 "),e("code",[_._v("new Thread()")]),_._v(" 比较消耗性能，创建一个线程是比较耗时、耗资源的。")]),_._v(" "),e("p",[_._v("调用 "),e("code",[_._v("new Thread()")]),_._v(" 创建的线程缺乏管理，而且可以无限制的创建，线程之间的相互竞争会导致过多占用系统资源而导致系统瘫痪，还有线程之间的频繁交替也会消耗很多系统资源。")]),_._v(" "),e("p",[_._v("直接使用 "),e("code",[_._v("new Thread()")]),_._v(" 启动的线程不利于扩展，比如定时执行、定期执行、定时定期执行、线程中断等都不便实现。")]),_._v(" "),e("h2",{attrs:{id:"_8、在-java-中-executor-和-executors-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8、在-java-中-executor-和-executors-的区别"}},[_._v("#")]),_._v(" 8、在 Java 中 Executor 和 Executors 的区别")]),_._v(" "),e("p",[e("code",[_._v("Executors")]),_._v(" 工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。")]),_._v(" "),e("p",[e("code",[_._v("Executor")]),_._v(" 接口对象能执行我们的线程任务。")]),_._v(" "),e("p",[e("code",[_._v("ExecutorService")]),_._v(" 接口继承了 "),e("code",[_._v("Executor")]),_._v(" 接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。")]),_._v(" "),e("p",[_._v("使用 "),e("code",[_._v("ThreadPoolExecutor")]),_._v(" 可以创建自定义线程池。")]),_._v(" "),e("h2",{attrs:{id:"_9、什么是原子操作，在-java-concurrency-api-中有哪些原子类-atomicclasses"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_9、什么是原子操作，在-java-concurrency-api-中有哪些原子类-atomicclasses"}},[_._v("#")]),_._v(" 9、什么是原子操作，在 Java Concurrency API 中有哪些原子类(atomicclasses)")]),_._v(" "),e("p",[_._v("原子操作（"),e("code",[_._v("atomic operation")]),_._v("）意为”不可被中断的一个或一系列操作” 。")]),_._v(" "),e("p",[_._v("处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。")]),_._v(" "),e("p",[_._v("在 "),e("code",[_._v("Java")]),_._v(" 中可以通过锁和循环 "),e("code",[_._v("CAS")]),_._v(" 的方式来实现原子操作。 "),e("code",[_._v("CAS")]),_._v(" 操作—— "),e("code",[_._v("Compare and Set")]),_._v("，或是 "),e("code",[_._v("Compare and Swap")]),_._v("，现在几乎所有的 "),e("code",[_._v("CPU")]),_._v(" 指令都支持 "),e("code",[_._v("CAS")]),_._v(" 的原子操作。")]),_._v(" "),e("p",[e("code",[_._v("java.util.concurrent.atomic")]),_._v(" 下提供了大量的原子操作类，比如")]),_._v(" "),e("p",[_._v("原子类：")]),_._v(" "),e("p",[_._v("AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference")]),_._v(" "),e("p",[_._v("原子数组：")]),_._v(" "),e("p",[_._v("AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray")]),_._v(" "),e("p",[_._v("原子属性更新器：")]),_._v(" "),e("p",[_._v("AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater")]),_._v(" "),e("h2",{attrs:{id:"_10、java-concurrency-api-中的-lock-接口-lock-interface-是什么？对比-synchronized-它有什么优势"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_10、java-concurrency-api-中的-lock-接口-lock-interface-是什么？对比-synchronized-它有什么优势"}},[_._v("#")]),_._v(" 10、Java Concurrency API 中的 Lock 接口(Lock interface)是什么？对比 synchronized 它有什么优势")]),_._v(" "),e("p",[e("code",[_._v("Lock")]),_._v(" 接口比同步方法和同步块提供了更具扩展性的锁操作。")]),_._v(" "),e("p",[_._v("他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。")]),_._v(" "),e("p",[_._v("它的优势有：可以使锁更公平，可以使线程在等待锁的时候响应中断，可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间，可以在不同的范围，以不同的顺序获取和释放锁。")]),_._v(" "),e("p",[_._v("整体上来说 "),e("code",[_._v("Lock")]),_._v(" 是 "),e("code",[_._v("synchronized")]),_._v(" 的扩展版，"),e("code",[_._v("Lock")]),_._v(" 提供了无条件的、可轮询的("),e("code",[_._v("tryLock()")]),_._v(" 方法)、定时的("),e("code",[_._v("tryLock()")]),_._v(" 带参方法)、可中断的("),e("code",[_._v("lockInterruptibly()")]),_._v(")、可多条件队列的("),e("code",[_._v("newCondition()")]),_._v(" 方法)锁操作。另外 "),e("code",[_._v("Lock")]),_._v(" 的实现类基本都支持非公平锁(默认)和公平锁，"),e("code",[_._v("synchronized")]),_._v(" 只支持非公平锁，当然，在大部分情况下，非公平锁是高效的选择。")]),_._v(" "),e("h2",{attrs:{id:"_11、什么是阻塞队列，阻塞队列的实现原理是什么，如何使用阻塞队列来实现生产者-消费者模型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_11、什么是阻塞队列，阻塞队列的实现原理是什么，如何使用阻塞队列来实现生产者-消费者模型"}},[_._v("#")]),_._v(" 11、什么是阻塞队列，阻塞队列的实现原理是什么，如何使用阻塞队列来实现生产者-消费者模型")]),_._v(" "),e("p",[_._v("阻塞队列（"),e("code",[_._v("BlockingQueue")]),_._v("）是一个支持两个附加操作的队列。")]),_._v(" "),e("p",[_._v("这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。")]),_._v(" "),e("p",[_._v("阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。")]),_._v(" "),e("p",[e("code",[_._v("JDK7")]),_._v(" 提供了 7 个阻塞队列。在实现上，主要是利用了 "),e("code",[_._v("Condition")]),_._v(" 和 "),e("code",[_._v("Lock")]),_._v(" 的等待通知模式。")]),_._v(" "),e("h2",{attrs:{id:"_12、什么是-callable-和-future"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_12、什么是-callable-和-future"}},[_._v("#")]),_._v(" 12、什么是 "),e("code",[_._v("Callable")]),_._v(" 和 "),e("code",[_._v("Future")]),_._v("?")]),_._v(" "),e("p",[e("code",[_._v("Callable")]),_._v(" 接口类似于 "),e("code",[_._v("Runnable")]),_._v("，从名字就可以看出来了，但是 "),e("code",[_._v("Runnable")]),_._v(" 不会返回结果，并且无法抛出返回结果的异常，而 "),e("code",[_._v("Callable")]),_._v(" 功能更强大一些，被线程执行后，可以返回值，这个返回值可以被 "),e("code",[_._v("Future")]),_._v(" 拿到，也就是说，"),e("code",[_._v("Future")]),_._v(" 可以拿到异步执行任务的返回值。"),e("code",[_._v("Callable")]),_._v(" 可以认为是带有回调的 "),e("code",[_._v("Runnable")]),_._v("。")]),_._v(" "),e("p",[e("code",[_._v("Future")]),_._v(" 接口表示异步任务，是还没有完成的任务给出的未来结果。所以说 "),e("code",[_._v("Callable")]),_._v(" 用于产生结果，"),e("code",[_._v("Future")]),_._v(" 用于获取结果。")]),_._v(" "),e("h2",{attrs:{id:"_13、什么是-futuretask"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_13、什么是-futuretask"}},[_._v("#")]),_._v(" 13、什么是 FutureTask")]),_._v(" "),e("p",[_._v("在 "),e("code",[_._v("Java")]),_._v(" 并发程序中 "),e("code",[_._v("FutureTask")]),_._v(" 表示一个可以取消的异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成 "),e("code",[_._v("get()")]),_._v(" 方法将会阻塞。一个 "),e("code",[_._v("FutureTask")]),_._v(" 对象可以对调用了 "),e("code",[_._v("Callable")]),_._v(" 和 "),e("code",[_._v("Runnable")]),_._v(" 的对象进行包装，由于 "),e("code",[_._v("FutureTask")]),_._v(" 也是调用了 "),e("code",[_._v("Runnable")]),_._v(" 接口所以它可以提交给 "),e("code",[_._v("Executor")]),_._v(" 来执行。")]),_._v(" "),e("h2",{attrs:{id:"_14、什么是并发容器的实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_14、什么是并发容器的实现"}},[_._v("#")]),_._v(" 14、什么是并发容器的实现")]),_._v(" "),e("p",[_._v("何为同步容器：可以简单地理解为通过 "),e("code",[_._v("synchronized")]),_._v(" 来实现同步的容器，如果有多个线程调用同步容器的方法，它们将会串行执行。比如 "),e("code",[_._v("Vector")]),_._v("，"),e("code",[_._v("Hashtable")]),_._v("，以及 "),e("code",[_._v("Collections.synchronizedSet")]),_._v("，"),e("code",[_._v("synchronizedList")]),_._v(" 等方法返回的容器。")]),_._v(" "),e("p",[_._v("并发容器使用了与同步容器完全不同的加锁策略来提供更高的并发性和伸缩性，例如在 "),e("code",[_._v("ConcurrentHashMap")]),_._v(" 中采用了一种粒度更细的加锁机制，可以称为分段锁，在这种锁机制下，允许任意数量的读线程并发地访问 "),e("code",[_._v("map")]),_._v("，并且执行读操作的线程和写操作的线程也可以并发的访问 "),e("code",[_._v("map")]),_._v("，同时允许一定数量的写操作线程并发地修改 "),e("code",[_._v("map")]),_._v("，所以它可以在并发环境下实现更高的吞吐量。")]),_._v(" "),e("h2",{attrs:{id:"_15、多线程同步和互斥有几种实现方法，都是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_15、多线程同步和互斥有几种实现方法，都是什么"}},[_._v("#")]),_._v(" 15、多线程同步和互斥有几种实现方法，都是什么")]),_._v(" "),e("p",[_._v("线程同步是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。")]),_._v(" "),e("p",[_._v("线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用\n其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。")]),_._v(" "),e("p",[_._v("线程间的同步方法大体可分为两类：用户模式和内核模式。顾名思义，内核模式就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态，而用户模式就是不需要切换到内核态，只在用户态完成操作。")]),_._v(" "),e("p",[_._v("用户模式下的方法有：原子操作（例如一个单一的全局变量），临界区。内核模式下的方法有：事件，信号量，互斥量。")]),_._v(" "),e("h2",{attrs:{id:"_16、什么是竞争条件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_16、什么是竞争条件"}},[_._v("#")]),_._v(" 16、什么是竞争条件")]),_._v(" "),e("p",[_._v("当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的顺序时，则我们认为这发生了竞争条件（"),e("code",[_._v("race condition")]),_._v("）。")]),_._v(" "),e("h2",{attrs:{id:"_17、为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_17、为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法"}},[_._v("#")]),_._v(" 17、为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法")]),_._v(" "),e("p",[_._v("当你调用 "),e("code",[_._v("start()")]),_._v(" 方法时你将创建新的线程，并且执行在 "),e("code",[_._v("run()")]),_._v(" 方法里的代码。")]),_._v(" "),e("p",[_._v("但是如果你直接调用 "),e("code",[_._v("run()")]),_._v(" 方法，它不会创建新的线程也不会执行调用线程的代码，只会把 "),e("code",[_._v("run()")]),_._v(" 方法当作普通方法去执行。")]),_._v(" "),e("h2",{attrs:{id:"_18、在-java-中-cyclicbarrier-和-countdownlatch-有什么区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_18、在-java-中-cyclicbarrier-和-countdownlatch-有什么区别"}},[_._v("#")]),_._v(" 18、在 Java 中 CyclicBarrier 和 CountdownLatch 有什么区别")]),_._v(" "),e("p",[e("code",[_._v("CyclicBarrier")]),_._v(" 可以重复使用，而 "),e("code",[_._v("CountdownLatch")]),_._v(" 不能重复使用。")]),_._v(" "),e("h2",{attrs:{id:"_19、什么是不可变对象，它对写并发应用有什么帮助"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_19、什么是不可变对象，它对写并发应用有什么帮助"}},[_._v("#")]),_._v(" 19、什么是不可变对象，它对写并发应用有什么帮助")]),_._v(" "),e("p",[_._v("不可变对象("),e("code",[_._v("Immutable Objects")]),_._v(")即对象一旦被创建它的状态（对象的数据，也即对象属性值）就不能改变，反之即为可变对象("),e("code",[_._v("Mutable Objects")]),_._v(")。")]),_._v(" "),e("p",[_._v("不可变对象的类即为不可变类("),e("code",[_._v("Immutable Class")]),_._v(")。"),e("code",[_._v("Java")]),_._v(" 平台类库中包含许多不可变类，如 "),e("code",[_._v("String")]),_._v("、基本类型的包装类、"),e("code",[_._v("BigInteger")]),_._v(" 和 "),e("code",[_._v("BigDecimal")]),_._v(" 等。")]),_._v(" "),e("p",[_._v("不可变对象天生是线程安全的。它们的常量（域）是在构造函数中创建的。既然它们的状态无法修改，这些常量永远不会变。")]),_._v(" "),e("p",[_._v("不可变对象永远是线程安全的。")]),_._v(" "),e("p",[_._v("只有满足如下状态，一个对象才是不可变的；")]),_._v(" "),e("ul",[e("li",[_._v("它的状态不能在创建后再被修改；")]),_._v(" "),e("li",[_._v("所有域都是 "),e("code",[_._v("final")]),_._v(" 类型；并且，它被正确创建")])]),_._v(" "),e("h2",{attrs:{id:"_20、notify-和-notifyall-有什么区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_20、notify-和-notifyall-有什么区别"}},[_._v("#")]),_._v(" 20、notify()和 notifyAll()有什么区别")]),_._v(" "),e("p",[_._v("当一个线程进入 "),e("code",[_._v("wait()")]),_._v(" 之后，就必须等其他线程 "),e("code",[_._v("notify()")]),_._v("/"),e("code",[_._v("notifyAll()")]),_._v("，使用 "),e("code",[_._v("notifyall")]),_._v("，可以唤醒所有处于 "),e("code",[_._v("wait()")]),_._v(" 状态的线程，使其重新进入锁的争夺队列中，而 "),e("code",[_._v("notify()")]),_._v("\n只能唤醒一个。")]),_._v(" "),e("p",[_._v("如果没把握，建议 "),e("code",[_._v("notifyAll()")]),_._v("，防止 "),e("code",[_._v("notify()")]),_._v(" 因为信号丢失而造成程序异常。")]),_._v(" "),e("h2",{attrs:{id:"_21、什么是可重入锁（reentrantlock），谈谈它的实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_21、什么是可重入锁（reentrantlock），谈谈它的实现"}},[_._v("#")]),_._v(" 21、什么是可重入锁（ReentrantLock），谈谈它的实现")]),_._v(" "),e("p",[_._v("线程可以重复进入任何一个它已经拥有的锁所同步着的代码块，"),e("code",[_._v("synchronized")]),_._v("、"),e("code",[_._v("ReentrantLock")]),_._v(" 都是可重入的锁。在实现上，就是线程每次获取锁时判定如果获得锁的线程是它自己时，简单将计数器累积即可，每 释放一次锁，进行计数器累减，直到计算器归零，表示线程已经彻底释放锁。")]),_._v(" "),e("h2",{attrs:{id:"_22、当一个线程进入某个对象的一个-synchronized-的实例方法后，其它线程是否可进入此对象的其它方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_22、当一个线程进入某个对象的一个-synchronized-的实例方法后，其它线程是否可进入此对象的其它方法"}},[_._v("#")]),_._v(" 22、当一个线程进入某个对象的一个 synchronized 的实例方法后，其它线程是否可进入此对象的其它方法")]),_._v(" "),e("p",[_._v("如果其他方法没有 "),e("code",[_._v("synchronized")]),_._v(" 的话，其他线程是可以进入的。")]),_._v(" "),e("p",[_._v("所以要开放一个线程安全的对象时，得保证每个方法都是线程安全的。")]),_._v(" "),e("h2",{attrs:{id:"_23、乐观锁和悲观锁的理解及如何实现，有哪些实现方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_23、乐观锁和悲观锁的理解及如何实现，有哪些实现方式"}},[_._v("#")]),_._v(" 23、乐观锁和悲观锁的理解及如何实现，有哪些实现方式")]),_._v(" "),e("ul",[e("li",[_._v("悲观锁")])]),_._v(" "),e("p",[_._v("总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。"),e("code",[_._v("Java")]),_._v(" 里面的同步原语 "),e("code",[_._v("synchronized")]),_._v(" 关键字的实现是悲观锁。")]),_._v(" "),e("ul",[e("li",[_._v("乐观锁")])]),_._v(" "),e("p",[_._v("顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。在 "),e("code",[_._v("Java")]),_._v(" 中原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。")]),_._v(" "),e("p",[_._v("乐观锁的实现方式：")]),_._v(" "),e("ul",[e("li",[e("p",[_._v("使用版本标识来确定读到的数据与提交时的数据是否一致。提交后修改版本标识，不一致时可以采取丢弃和再次尝试的策略。")])]),_._v(" "),e("li",[e("p",[e("code",[_._v("java")]),_._v(" 中的 "),e("code",[_._v("Compare and Swap")]),_._v(" 即 "),e("code",[_._v("CAS")]),_._v(" ，当多个线程尝试使用 "),e("code",[_._v("CAS")]),_._v(" 同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。")])])]),_._v(" "),e("h2",{attrs:{id:"_24、什么是-cas-操作，缺点是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_24、什么是-cas-操作，缺点是什么"}},[_._v("#")]),_._v(" 24、什么是 CAS 操作，缺点是什么")]),_._v(" "),e("p",[e("code",[_._v("CA")]),_._v(" 的基本思路就是，如果这个地址上的值和期望的值相等，则给其赋予新值，否则不做任何事儿，但是要返回原值是多少。每一个 "),e("code",[_._v("CAS")]),_._v(" 操作过程都包含三个运算符：一个内存地址 "),e("code",[_._v("V")]),_._v("，一个期望的值 "),e("code",[_._v("A")]),_._v(" 和一个新值 "),e("code",[_._v("B")]),_._v("，操作的时候如果这个地址上存放的值等于这个期望的值 "),e("code",[_._v("A")]),_._v("，则将地址上的值赋为新值 "),e("code",[_._v("B")]),_._v("，否则不做任何操作。")]),_._v(" "),e("p",[_._v("CAS 缺点：")]),_._v(" "),e("ul",[e("li",[_._v("ABA 问题")])]),_._v(" "),e("p",[_._v("比如说一个线程 "),e("code",[_._v("one")]),_._v(" 从内存位置 "),e("code",[_._v("V")]),_._v(" 中取出 "),e("code",[_._v("A")]),_._v("，这时候另一个线程 "),e("code",[_._v("two")]),_._v(" 也从内存中取出 "),e("code",[_._v("A")]),_._v("，并且 "),e("code",[_._v("two")]),_._v(" 进行了一些操作变成了 "),e("code",[_._v("B")]),_._v("，然后 "),e("code",[_._v("two")]),_._v(" 又将 "),e("code",[_._v("V")]),_._v(" 位置的数据变成 "),e("code",[_._v("A")]),_._v("，这时候线程 "),e("code",[_._v("one")]),_._v(" 进行 "),e("code",[_._v("CAS")]),_._v(" 操作发现内存中仍然是 "),e("code",[_._v("A")]),_._v("，然后 "),e("code",[_._v("one")]),_._v(" 操作成功。尽管线程 "),e("code",[_._v("one")]),_._v(" 的 "),e("code",[_._v("CAS")]),_._v(" 操作成功，但可能存在潜藏的问题。从 "),e("code",[_._v("Java1.5")]),_._v(" 开始 "),e("code",[_._v("JDK")]),_._v(" 的 "),e("code",[_._v("atomic")]),_._v(" 包里提供了一个类 "),e("code",[_._v("AtomicStampedReference")]),_._v(" 来解决 "),e("code",[_._v("ABA")]),_._v(" 问题。")]),_._v(" "),e("p",[_._v("循环时间长开销大：")]),_._v(" "),e("p",[_._v("对于资源竞争严重（线程冲突严重）的情况，"),e("code",[_._v("CAS")]),_._v(" 自旋的概率会比较大，从而浪费更多的 "),e("code",[_._v("CPU")]),_._v(" 资源，效率低于 "),e("code",[_._v("synchronized")]),_._v("。")]),_._v(" "),e("p",[_._v("只能保证一个共享变量的原子操作：")]),_._v(" "),e("p",[_._v("当对一个共享变量执行操作时，我们可以使用循环 "),e("code",[_._v("CAS")]),_._v(" 的方式来保证原子操作，但是对多个共享变量操作时，循环 "),e("code",[_._v("CAS")]),_._v(" 就无法保证操作的原子性，这个时候就可以用锁。")]),_._v(" "),e("h2",{attrs:{id:"_25、synchronizedmap-和-concurrenthashmap-有什么区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_25、synchronizedmap-和-concurrenthashmap-有什么区别"}},[_._v("#")]),_._v(" 25、SynchronizedMap 和 ConcurrentHashMap 有什么区别")]),_._v(" "),e("p",[e("code",[_._v("SynchronizedMap")]),_._v(" 一次锁住整张表来保证线程安全，所以每次只能有一个线程来访为 "),e("code",[_._v("map")]),_._v("。")]),_._v(" "),e("p",[e("code",[_._v("ConcurrentHashMap")]),_._v(" 使用分段锁来保证在多线程下的性能。")]),_._v(" "),e("h2",{attrs:{id:"_26、写时复制容器可以用于什么应用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_26、写时复制容器可以用于什么应用场景"}},[_._v("#")]),_._v(" 26、写时复制容器可以用于什么应用场景")]),_._v(" "),e("p",[e("code",[_._v("CopyOnWrite")]),_._v(" 并发容器用于对于绝大部分访问都是读，且只是偶尔写的并发场景。比如白名单，黑名单，商品类目的访问和更新场景。")]),_._v(" "),e("p",[_._v("透露的思想：读写分离，读和写分开；最终一致性；使用另外开辟空间的思路，来解决并发冲突")]),_._v(" "),e("h2",{attrs:{id:"_27、volatile-有什么用，能否用一句话说明下-volatile-的应用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_27、volatile-有什么用，能否用一句话说明下-volatile-的应用场景"}},[_._v("#")]),_._v(" 27、volatile 有什么用，能否用一句话说明下 volatile 的应用场景")]),_._v(" "),e("p",[e("code",[_._v("volatile")]),_._v(" 保证内存可见性和禁止指令重排。")]),_._v(" "),e("p",[e("code",[_._v("volatile")]),_._v(" 用于多线程环境下的一写多读，或者无关联的多写")]),_._v(" "),e("h2",{attrs:{id:"_28、为什么代码会重排序"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_28、为什么代码会重排序"}},[_._v("#")]),_._v(" 28、为什么代码会重排序")]),_._v(" "),e("p",[_._v("在执行程序时，为了提供性能，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，不是你想怎么排序就怎么排序，它需要满足以下两个条件：")]),_._v(" "),e("ol",[e("li",[_._v("在单线程环境下不能改变程序运行的结果；")]),_._v(" "),e("li",[_._v("存在数据依赖关系的不允许重排序")])]),_._v(" "),e("h2",{attrs:{id:"_29、在-java-中-wait-和-sleep-方法的不同"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_29、在-java-中-wait-和-sleep-方法的不同"}},[_._v("#")]),_._v(" 29、在 java 中 wait 和 sleep 方法的不同")]),_._v(" "),e("p",[_._v("最大的不同是在等待时 "),e("code",[_._v("wait()")]),_._v(" 会释放锁，而 "),e("code",[_._v("sleep()")]),_._v(" 一直持有锁。"),e("code",[_._v("wait()")]),_._v(" 通常被用于线程间交互，"),e("code",[_._v("sleep()")]),_._v(" 通常被用于暂停执行。")]),_._v(" "),e("h2",{attrs:{id:"_30、一个线程运行时发生异常会怎样"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_30、一个线程运行时发生异常会怎样"}},[_._v("#")]),_._v(" 30、一个线程运行时发生异常会怎样")]),_._v(" "),e("p",[_._v("如果异常没有被捕获该线程将会停止执行。"),e("code",[_._v("Thread.UncaughtExceptionHandler")]),_._v(" 是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候 "),e("code",[_._v("JVM")]),_._v(" 会使用 "),e("code",[_._v("Thread.getUncaughtExceptionHandler()")]),_._v(" 来查询线程的 "),e("code",[_._v("UncaughtExceptionHandler")]),_._v(" 并将线程和异常作为参数传递给 "),e("code",[_._v("handler")]),_._v(" 的 "),e("code",[_._v("uncaughtException()")]),_._v(" 方法进行处理。")]),_._v(" "),e("h2",{attrs:{id:"_31、为什么-wait-notify-和-notifyall-这些方法不在-thread-类里面"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_31、为什么-wait-notify-和-notifyall-这些方法不在-thread-类里面"}},[_._v("#")]),_._v(" 31、为什么 wait, notify 和 notifyAll 这些方法不在 thread 类里面")]),_._v(" "),e("p",[e("code",[_._v("Java")]),_._v(" 提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的 "),e("code",[_._v("wait()")]),_._v(" 方法就有意义了。如果 "),e("code",[_._v("wait()")]),_._v(" 方法定义在 "),e("code",[_._v("Thread")]),_._v(" 类中，线程正在等待的是哪个锁就不明显了。简单的说，由于 "),e("code",[_._v("wait()")]),_._v("，"),e("code",[_._v("notify()")]),_._v(" 和 "),e("code",[_._v("notifyAll()")]),_._v(" 都是锁级别的操作，所以把他们定义在 "),e("code",[_._v("Object")]),_._v(" 类中因为锁属于对象。")]),_._v(" "),e("h2",{attrs:{id:"_32、什么是-threadlocal-变量"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_32、什么是-threadlocal-变量"}},[_._v("#")]),_._v(" 32、什么是 ThreadLocal 变量")]),_._v(" "),e("p",[e("code",[_._v("ThreadLocal")]),_._v(" 是 "),e("code",[_._v("Java")]),_._v(" 里一种特殊的变量。每个线程都有一个 "),e("code",[_._v("ThreadLocal")]),_._v(" 就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。")]),_._v(" "),e("h2",{attrs:{id:"_33、java-中-interrupted-和-isinterrupted-方法的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_33、java-中-interrupted-和-isinterrupted-方法的区别"}},[_._v("#")]),_._v(" 33、Java 中 interrupted 和 isInterrupted 方法的区别")]),_._v(" "),e("p",[e("code",[_._v("interrupted()")]),_._v(" 和 "),e("code",[_._v("isInterrupted()")]),_._v(" 的主要区别是前者会将中断状态清除而后者不会。"),e("code",[_._v("Java")]),_._v(" 多线程的中断机制是用内部标识来实现的，调用 "),e("code",[_._v("Thread.interrupt()")]),_._v(" 来中断一个线程就会设置中断标识为 "),e("code",[_._v("true")]),_._v("。当中断线程调用静态方法 "),e("code",[_._v("Thread.interrupted()")]),_._v(" 来检查中断状态时，中断状态会被清零。而非静态方法 "),e("code",[_._v("isInterrupted()")]),_._v(" 用来查询其它线程的中断状态且不会改变中断状态标识。")]),_._v(" "),e("h2",{attrs:{id:"_34、为什么-wait-和-notify-方法要在同步块中调用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_34、为什么-wait-和-notify-方法要在同步块中调用"}},[_._v("#")]),_._v(" 34、为什么 wait 和 notify 方法要在同步块中调用")]),_._v(" "),e("p",[_._v("主要是因为 "),e("code",[_._v("Java API")]),_._v(" 强制要求这样做，如果你不这么做，你的代码会抛出 "),e("code",[_._v("IllegalMonitorStateException")]),_._v(" 异常。")]),_._v(" "),e("h2",{attrs:{id:"_35、为什么你应该在循环中检查等待条件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_35、为什么你应该在循环中检查等待条件"}},[_._v("#")]),_._v(" 35、为什么你应该在循环中检查等待条件")]),_._v(" "),e("p",[_._v("处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。因此，当一个等待线程醒来时，不能认为它原来的等待状态仍然是有效的，在 "),e("code",[_._v("notify()")]),_._v(" 方法调用之后和等待线程醒来之前这段时间它可能会改变。这就是在循环中使用 "),e("code",[_._v("wait()")]),_._v(" 方法效果更好的原因")]),_._v(" "),e("h2",{attrs:{id:"_36、怎么检测一个线程是否拥有锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_36、怎么检测一个线程是否拥有锁"}},[_._v("#")]),_._v(" 36、怎么检测一个线程是否拥有锁")]),_._v(" "),e("p",[_._v("在 "),e("code",[_._v("java.lang.Thread")]),_._v(" 中有一个方法叫 "),e("code",[_._v("holdsLock()")]),_._v("，它返回 "),e("code",[_._v("true")]),_._v(" 如果当且仅当当前线程拥有某个具体对象的锁。")]),_._v(" "),e("h2",{attrs:{id:"_37、你如何在-java-中获取线程堆栈"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_37、你如何在-java-中获取线程堆栈"}},[_._v("#")]),_._v(" 37、你如何在 Java 中获取线程堆栈")]),_._v(" "),e("ul",[e("li",[_._v("kill -3 [java pid]")])]),_._v(" "),e("p",[_._v("不会在当前终端输出，它会输出到代码执行的或指定的地方去。比如，"),e("code",[_._v("kill -3 tomcat pid")]),_._v(", 输出堆栈到 log 目录下。")]),_._v(" "),e("ul",[e("li",[_._v("Jstack [java pid]")])]),_._v(" "),e("p",[_._v("这个比较简单，在当前终端显示，也可以重定向到指定文件中。")]),_._v(" "),e("p",[_._v("或者使用 "),e("code",[_._v("Java")]),_._v(" 提供的拟机线程系统的管理接口 "),e("code",[_._v("ManagementFactory.getThreadMXBean()")]),_._v("。")]),_._v(" "),e("h2",{attrs:{id:"_38、java-线程池中-submit-和-execute-方法有什么区别？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_38、java-线程池中-submit-和-execute-方法有什么区别？"}},[_._v("#")]),_._v(" 38、Java 线程池中 submit() 和 execute()方法有什么区别？")]),_._v(" "),e("p",[_._v("两个方法都可以向线程池提交任务，"),e("code",[_._v("execute()")]),_._v(" 方法的返回类型是 "),e("code",[_._v("void")]),_._v("，它定义在 "),e("code",[_._v("Executor")]),_._v(" 接口中。")]),_._v(" "),e("p",[_._v("而 "),e("code",[_._v("submit()")]),_._v(" 方法可以返回持有计算结果的 "),e("code",[_._v("Future")]),_._v(" 对象，它定义在 "),e("code",[_._v("ExecutorService")]),_._v(" 接口中，它扩展了 "),e("code",[_._v("Executor")]),_._v(" 接口")]),_._v(" "),e("h2",{attrs:{id:"_39、你对线程优先级的理解是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_39、你对线程优先级的理解是什么"}},[_._v("#")]),_._v(" 39、你对线程优先级的理解是什么")]),_._v(" "),e("p",[_._v("每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的("),e("code",[_._v("OS dependent")]),_._v(")。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个 "),e("code",[_._v("int")]),_._v(" 变量(从 1-10)，1 代表最低优先级，10 代表最高优先级。")]),_._v(" "),e("p",[e("code",[_._v("Java")]),_._v(" 的线程优先级调度会委托给操作系统去处理，所以与具体的操作系统优先级有关，如非特别需要，一般无需设置线程优先级。")]),_._v(" "),e("h2",{attrs:{id:"_40、你如何确保-main-方法所在的线程是-java-程序最后结束的线程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_40、你如何确保-main-方法所在的线程是-java-程序最后结束的线程"}},[_._v("#")]),_._v(" 40、你如何确保 main()方法所在的线程是 Java 程序最后结束的线程")]),_._v(" "),e("p",[_._v("可以使用 "),e("code",[_._v("Thread")]),_._v(" 类的 "),e("code",[_._v("join()")]),_._v(" 方法（或者 "),e("code",[_._v("CountDownLatch")]),_._v(" 工具类）来确保所有程序创建的线程在 "),e("code",[_._v("main()")]),_._v(" 方法退出前结束。")]),_._v(" "),e("h2",{attrs:{id:"_41、为什么-thread-类的-sleep-和-yield-方法是静态的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_41、为什么-thread-类的-sleep-和-yield-方法是静态的"}},[_._v("#")]),_._v(" 41、为什么 "),e("code",[_._v("Thread")]),_._v(" 类的 "),e("code",[_._v("sleep()")]),_._v(" 和 "),e("code",[_._v("yield()")]),_._v(" 方法是静态的")]),_._v(" "),e("p",[e("code",[_._v("Thread")]),_._v(" 类的 "),e("code",[_._v("sleep()")]),_._v(" 和 "),e("code",[_._v("yield()")]),_._v(" 方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。")]),_._v(" "),e("h2",{attrs:{id:"_42、现在有-t1、t2、t3-三个线程，你怎样保证-t2-在-t1-执行完后执行，t3-在t2-执行完后执行"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_42、现在有-t1、t2、t3-三个线程，你怎样保证-t2-在-t1-执行完后执行，t3-在t2-执行完后执行"}},[_._v("#")]),_._v(" 42、现在有 T1、T2、T3 三个线程，你怎样保证 T2 在 T1 执行完后执行，T3 在T2 执行完后执行")]),_._v(" "),e("p",[_._v("可以用 "),e("code",[_._v("join")]),_._v(" 方法实现")]),_._v(" "),e("h2",{attrs:{id:"_43、你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_43、你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它"}},[_._v("#")]),_._v(" 43、你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它")]),_._v(" "),e("p",[e("code",[_._v("volatile")]),_._v(" 关键字，读写锁，写时复制等等都可以实现")]),_._v(" "),e("h2",{attrs:{id:"_44、用-java-实现阻塞队列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_44、用-java-实现阻塞队列"}},[_._v("#")]),_._v(" 44、用 Java 实现阻塞队列")]),_._v(" "),e("p",[_._v("参见这篇博客 "),e("RouterLink",{attrs:{to:"/backend/并发容器.html#_4、阻塞队列-blockingqueue"}},[_._v("并发容器")])],1),_._v(" "),e("h2",{attrs:{id:"_45、用-java-写代码来解决生产者——消费者问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_45、用-java-写代码来解决生产者——消费者问题"}},[_._v("#")]),_._v(" 45、用 Java 写代码来解决生产者——消费者问题")]),_._v(" "),e("p",[_._v("阻塞队列实现即可，也可以用 "),e("code",[_._v("wait()")]),_._v(" 和 "),e("code",[_._v("notify()")]),_._v(" 来解决这个问题，或者用 "),e("code",[_._v("Semaphore")])]),_._v(" "),e("h2",{attrs:{id:"_46、用-java-编程一个会导致死锁的程序，你将怎么解决"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_46、用-java-编程一个会导致死锁的程序，你将怎么解决"}},[_._v("#")]),_._v(" 46、用 Java 编程一个会导致死锁的程序，你将怎么解决")]),_._v(" "),e("p",[_._v("参见这篇博客 "),e("RouterLink",{attrs:{to:"/backend/并发安全.html#_2、现象、危害和解决"}},[_._v("并发安全")])],1),_._v(" "),e("h2",{attrs:{id:"_47、java-中如何停止一个线程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_47、java-中如何停止一个线程"}},[_._v("#")]),_._v(" 47、Java 中如何停止一个线程")]),_._v(" "),e("ul",[e("li",[_._v("使用共享变量的方式")])]),_._v(" "),e("p",[_._v("在这种方式中，之所以引入共享变量，是因为该变量可以被多个执行相同任务的线程用来作为是否中断的信号，通知中断线程的执行。")]),_._v(" "),e("ul",[e("li",[_._v("使用 interrupt 方法终止线程")])]),_._v(" "),e("p",[_._v("如果一个线程由于等待某些事件的发生而被阻塞，又该怎样停止该线程呢？比如当一个线程由于需要等候键盘输入而被阻塞，或者调用 "),e("code",[_._v("Thread.join()")]),_._v(" 方法，或者 "),e("code",[_._v("Thread.sleep()")]),_._v(" 方法，在网络中调用 "),e("code",[_._v("ServerSocket.accept()")]),_._v(" 方法，或者调用了 "),e("code",[_._v("DatagramSocket.receive()")]),_._v(" 方法时，都有可能导致线程阻塞，使线程处于处于不可运行状态时，即使主程序中将该线程的共享变量设置为 "),e("code",[_._v("true")]),_._v("，但该线程此时根本无法检查循环标志，当然也就无法立即中断。所以应该尽量使用 "),e("code",[_._v("Thread")]),_._v(" 提供的 "),e("code",[_._v("interrupt()")]),_._v(" 方法，因为该方法虽然不会中断一个正在运行的线程，但是它可以使一个被阻塞的线程抛出一个中断异常，从而使线程提前结束阻塞状态。")]),_._v(" "),e("h2",{attrs:{id:"_48、jvm-中哪个参数是用来控制线程的栈堆栈大小的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_48、jvm-中哪个参数是用来控制线程的栈堆栈大小的"}},[_._v("#")]),_._v(" 48、JVM 中哪个参数是用来控制线程的栈堆栈大小的")]),_._v(" "),e("p",[_._v("-Xss")]),_._v(" "),e("h2",{attrs:{id:"_49、如果同步块内的线程抛出异常锁会释放吗"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_49、如果同步块内的线程抛出异常锁会释放吗"}},[_._v("#")]),_._v(" 49、如果同步块内的线程抛出异常锁会释放吗")]),_._v(" "),e("p",[_._v("会")]),_._v(" "),e("h2",{attrs:{id:"_50、单例模式的双重检查实现是什么？为什么并不安全？如何在-java-中创建线程安全的-singleton"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_50、单例模式的双重检查实现是什么？为什么并不安全？如何在-java-中创建线程安全的-singleton"}},[_._v("#")]),_._v(" 50、单例模式的双重检查实现是什么？为什么并不安全？如何在 Java 中创建线程安全的 Singleton")]),_._v(" "),e("p",[_._v("实现参见这篇博客 "),e("RouterLink",{attrs:{to:"/backend/并发安全.html#_1、双重检查锁"}},[_._v("并发安全")])],1),_._v(" "),e("p",[_._v("不安全的根本原因是重排序会导致未初始化完成的对象可以被其他线程看见而导致错误。")]),_._v(" "),e("p",[_._v("创建安全的单例模式有：延迟占位模式、在声明的时候就 "),e("code",[_._v("new")]),_._v(" 这个类的实例、枚举")]),_._v(" "),e("h2",{attrs:{id:"_51、写出-3-条你遵循的多线程最佳实践"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_51、写出-3-条你遵循的多线程最佳实践"}},[_._v("#")]),_._v(" 51、写出 3 条你遵循的多线程最佳实践")]),_._v(" "),e("p",[_._v("给你的线程起个有意义的名字。 这样可以方便找 "),e("code",[_._v("bug")]),_._v(" 或追踪。"),e("code",[_._v("OrderProcessor")]),_._v(", "),e("code",[_._v("QuoteProcessor")]),_._v(" 或者 "),e("code",[_._v("TradeProcessor")]),_._v(" 这种名字比 "),e("code",[_._v("Thread-1")]),_._v("、 "),e("code",[_._v("Thread-2")]),_._v(" 和 "),e("code",[_._v("Thread-3")]),_._v(" 好多了，给线程起一个和它要完成的任务相关的名字，所有的主要框架甚至 "),e("code",[_._v("JDK")]),_._v(" 都遵循这个最佳实践。")]),_._v(" "),e("p",[_._v("避免锁定和缩小同步的范围 锁花费的代价高昂且上下文切换更耗费时间空间，试试最低限度的使用同步和锁，缩小临界区。因此相对于同步方法我更喜欢同步块，它给我拥有对锁的绝对控制权。")]),_._v(" "),e("p",[_._v("多用同步类少用 "),e("code",[_._v("wait()")]),_._v(" 和 "),e("code",[_._v("notify()")]),_._v(" 首先，"),e("code",[_._v("CountDownLatch")]),_._v("，"),e("code",[_._v("Semaphore")]),_._v("， "),e("code",[_._v("CyclicBarrier")]),_._v(" 和 "),e("code",[_._v("Exchanger")]),_._v(" 这些同步类简化了编码操作，而用 "),e("code",[_._v("wait()")]),_._v(" 和 "),e("code",[_._v("notify()")]),_._v(" 很难实现对复杂控制流的控制。其次，这些类是由最好的企业编写和维护在后续的JDK中它们还会不断优化和完善，使用这些更高等级的同步工具你的程序可以不费吹灰之力获得优化。")]),_._v(" "),e("p",[_._v("多用并发集合少用同步集合 这是另外一个容易遵循且受益巨大的最佳实践，并发集合比同步集合的可扩展性更好，所以在并发编程时使用并发集合效果更好。")]),_._v(" "),e("p",[_._v("比如并发编程的黄金原则，尽量无锁化编程等等……")]),_._v(" "),e("h2",{attrs:{id:"_52、请概述线程池的创建参数，怎么样合理配置一个线程池的参数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_52、请概述线程池的创建参数，怎么样合理配置一个线程池的参数"}},[_._v("#")]),_._v(" 52、请概述线程池的创建参数，怎么样合理配置一个线程池的参数")]),_._v(" "),e("p",[_._v("参见这篇博客 "),e("RouterLink",{attrs:{to:"/backend/线程池.html"}},[_._v("线程池")])],1),_._v(" "),e("h2",{attrs:{id:"_53、请概述锁的公平和非公平，jdk-内部是如何实现的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_53、请概述锁的公平和非公平，jdk-内部是如何实现的"}},[_._v("#")]),_._v(" 53、请概述锁的公平和非公平，JDK 内部是如何实现的")]),_._v(" "),e("p",[_._v("公平锁是指所有试图获得锁的线程按照获取锁的顺序依次获得锁，而非公平锁则是当前的锁状态没有被占用时,当前线程可以直接占用,而不需要等待。在实现上，非公平锁逻辑基本跟公平锁一致，唯一的区别是，当前线程不需要判断同步队列中是否有等待线程。")]),_._v(" "),e("p",[_._v("非公平锁性能高于公平锁性能。首先，在恢复一个被挂起的线程与该线程真正运行之间存在着严重的延迟。而且，非公平锁能更充分的利用 "),e("code",[_._v("cpu")]),_._v(" 的时间片，尽量的减少 "),e("code",[_._v("cpu")]),_._v(" 空闲的状态时间。")]),_._v(" "),e("p",[_._v("使用场景的话呢，其实还是和他们的属性一一相关，比如：如果业务中线程占用(处理)时间要远长于线程等待，那用非公平锁其实效率并不明显，但是用公平锁可以保证不会有线程被饿死。")]),_._v(" "),e("h2",{attrs:{id:"_54、请概述-aqs"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_54、请概述-aqs"}},[_._v("#")]),_._v(" 54、请概述 AQS")]),_._v(" "),e("p",[_._v("是用来构建锁或者其他同步组件的基础框架，比如 "),e("code",[_._v("ReentrantLock")]),_._v("、"),e("code",[_._v("ReentrantReadWriteLock")]),_._v(" 和 "),e("code",[_._v("CountDownLatch")]),_._v(" 就是基于 "),e("code",[_._v("AQS")]),_._v(" 实现的。它使用了一个 "),e("code",[_._v("int")]),_._v(" 成员变量表示同步状态，通过内置的 "),e("code",[_._v("FIFO")]),_._v(" 队列来完成资源获取线程的排队工作。它是 "),e("code",[_._v("CLH")]),_._v(" 队列锁的一种变体实现。它可以实现 2 种同步方式：独占式，共享式。")]),_._v(" "),e("p",[e("code",[_._v("AQS")]),_._v(" 的主要使用方式是继承，子类通过继承 "),e("code",[_._v("AQS")]),_._v(" 并实现它的抽象方法来管理同步状态，同步器的设计基于模板方法模式，所以如果要实现我们自己的同步工具类就需要覆盖其中几个可重写的方法，如 "),e("code",[_._v("tryAcquire()")]),_._v("、"),e("code",[_._v("tryReleaseShared()")]),_._v(" 等等。")]),_._v(" "),e("p",[_._v("这样设计的目的是同步组件（比如锁）是面向使用者的，它定义了使用者与同步组件交互的接口（比如可以允许两个线程并行访问），隐藏了实现细节；同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。这样就很好地隔离了使用者和实现者所需关注的领域。")]),_._v(" "),e("p",[_._v("在内部，"),e("code",[_._v("AQS")]),_._v(" 维护一个共享资源 "),e("code",[_._v("state")]),_._v("，通过内置的 "),e("code",[_._v("FIFO")]),_._v(" 来完成获取资源线程的排队工作。该队列由一个一个的 "),e("code",[_._v("Node")]),_._v(" 结点组成，每个 "),e("code",[_._v("Node")]),_._v(" 结点维护一个 "),e("code",[_._v("prev")]),_._v(" 引用和 "),e("code",[_._v("next")]),_._v(" 引用，分别指向自己的前驱和后继结点，构成一个双端双向链表。")]),_._v(" "),e("p",[_._v("同时与 "),e("code",[_._v("Condition")]),_._v(" 相关的等待队列，节点类型也是 "),e("code",[_._v("Node")]),_._v("，构成一个单向链表。")]),_._v(" "),e("h2",{attrs:{id:"_55、请概述-volatile"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_55、请概述-volatile"}},[_._v("#")]),_._v(" 55、请概述 volatile")]),_._v(" "),e("p",[_._v("多线程主要围绕可见性和原子性两个特性而展开，使用 "),e("code",[_._v("volatile")]),_._v(" 关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到 "),e("code",[_._v("volatile")]),_._v(" 变量，一定是最新的数据。但是 "),e("code",[_._v("volatile")]),_._v(" 不能保证操作的原子，对任意单个 "),e("code",[_._v("volatile")]),_._v(" 变量的读/写具有原子性，但类似于++这种复合操作不具有原子性。")]),_._v(" "),e("p",[_._v("代码底层在执行时为了获取更好的性能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用 "),e("code",[_._v("volatile")]),_._v(" 则会对禁止重排序，当然这也一定程度上降低了代码执行效率。")]),_._v(" "),e("p",[_._v("同时在内存语义上，当写一个 "),e("code",[_._v("volatile")]),_._v(" 变量时，"),e("code",[_._v("JMM")]),_._v(" 会把该线程对应的本地内存中的共享变量值刷新到主内存，当读一个 "),e("code",[_._v("volatile")]),_._v(" 变量时，"),e("code",[_._v("JMM")]),_._v(" 会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。")]),_._v(" "),e("p",[_._v("在 "),e("code",[_._v("Java")]),_._v(" 中对于 "),e("code",[_._v("volatile")]),_._v(" 修饰的变量，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序问题、强制刷新和读取。")]),_._v(" "),e("p",[e("code",[_._v("volatile")]),_._v(" 关键字修饰的变量会存在一个“"),e("code",[_._v("lock:")]),_._v("”的前缀。它不是一种内存屏障，但是它能完成类似内存屏障的功能。"),e("code",[_._v("Lock")]),_._v(" 会对 "),e("code",[_._v("CPU")]),_._v(" 总线和高速缓存加锁，可以理解为 "),e("code",[_._v("CPU")]),_._v(" 指令级的一种锁。同时该指令会将当前处理器缓存行的数据直接写会到系统内存中，且这个写回内存的操作会使在其他 "),e("code",[_._v("CPU")]),_._v(" 里缓存了该地址的数据无效。")]),_._v(" "),e("Valine")],1)}),[],!1,null,null,null);v.default=t.exports}}]);