(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{232:function(_,v,e){"use strict";e.r(v);var t=e(0),a=Object(t.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h1",{attrs:{id:"mysql索引和执行计划"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mysql索引和执行计划"}},[_._v("#")]),_._v(" MySQL索引和执行计划")]),_._v(" "),e("Counter",{attrs:{path:"backend",name:"MySQL索引和执行计划"}}),_._v(" "),e("h2",{attrs:{id:"一、索引入门"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、索引入门"}},[_._v("#")]),_._v(" 一、索引入门")]),_._v(" "),e("h3",{attrs:{id:"_1、索引是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、索引是什么"}},[_._v("#")]),_._v(" 1、索引是什么")]),_._v(" "),e("h4",{attrs:{id:"_1-生活中的索引"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-生活中的索引"}},[_._v("#")]),_._v(" (1) 生活中的索引")]),_._v(" "),e("p",[e("code",[_._v("MySQL")]),_._v(" 官方对索引的定义为：索引（"),e("code",[_._v("Index")]),_._v("）是帮助 "),e("code",[_._v("MySQL")]),_._v(" 高效获取数据的数据结构。")]),_._v(" "),e("p",[_._v("可以得到索引的本质：索引是数据结构。")]),_._v(" "),e("p",[_._v("上面的理解比较抽象，举一个例子，平时看任何一本书，首先看到的都是目录，通过目录去查询书籍里面的内容会非常的迅速。")]),_._v(" "),e("p",[_._v("另外通过目录（索引），可以快速查询到目录里面的内容，它能高效获取数据，通过这个简单的案例可以理解索引就是高效获取数据的数据结构。")]),_._v(" "),e("p",[_._v("再来看一个复杂的情况：")]),_._v(" "),e("p",[_._v("我们要去图书馆找一本书，这图书馆的书肯定不是线性存放的，它对不同的书籍内容进行了分类存放，整索引由于一个个节点组成，根节点有中间节点，中间节点下面又由子节点，最\n后一层是叶子节点，可见，整个索引结构是一棵倒挂着的树，其实它就是一种数据结构，这种数据结构比前面讲到的线性目录更好的增加了查询的速度。")]),_._v(" "),e("h4",{attrs:{id:"_2-mysql-中的索引"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-mysql-中的索引"}},[_._v("#")]),_._v(" (2) MySql 中的索引")]),_._v(" "),e("p",[e("img",{attrs:{src:"https://yjtravel-public.oss-cn-beijing.aliyuncs.com/my-blog/basic/sql_index.png",alt:"sql_index"}})]),_._v(" "),e("p",[e("code",[_._v("MySql")]),_._v(" 中的索引其实也是这么一回事，我们可以在数据库中建立一系列的索引，比如创建主键的时候默认会创建主键索引。")]),_._v(" "),e("p",[_._v("上图是一种 "),e("code",[_._v("BTREE")]),_._v(" 的索引，左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址。每一个节点都是主键的 "),e("code",[_._v("ID")]),_._v("，当我们通过 "),e("code",[_._v("ID")]),_._v(" 来查询内容的时候，首先去查索引库，在到索引库后能快速的定位索引的具体位置。")]),_._v(" "),e("p",[e("code",[_._v("mysql")]),_._v(" 默认存储引擎 "),e("code",[_._v("innodb")]),_._v(" 只显式支持 "),e("code",[_._v("B-Tree")]),_._v("(从技术上来说是 "),e("code",[_._v("B+Tree")]),_._v(")索引。")]),_._v(" "),e("h3",{attrs:{id:"_2、索引的分类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、索引的分类"}},[_._v("#")]),_._v(" 2、索引的分类")]),_._v(" "),e("h4",{attrs:{id:"_1-普通索引"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-普通索引"}},[_._v("#")]),_._v(" (1) 普通索引")]),_._v(" "),e("p",[_._v("即一个索引只包含单个列，一个表可以有多个单列索引")]),_._v(" "),e("h4",{attrs:{id:"_2-唯一索引"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-唯一索引"}},[_._v("#")]),_._v(" (2) 唯一索引")]),_._v(" "),e("p",[_._v("索引列的值必须唯一，但允许有空值")]),_._v(" "),e("h4",{attrs:{id:"_3-复合索引"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-复合索引"}},[_._v("#")]),_._v(" (3) 复合索引")]),_._v(" "),e("p",[_._v("即一个索引包含多个列")]),_._v(" "),e("h4",{attrs:{id:"_4-聚簇索引-聚集索引"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-聚簇索引-聚集索引"}},[_._v("#")]),_._v(" (4) 聚簇索引(聚集索引)")]),_._v(" "),e("p",[_._v("并不是一种单独的索引类型，而是一种数据存储方式。具体细节取决于不同的实现，"),e("code",[_._v("InnoDB")]),_._v(" 的聚簇索引其实就是在同一个结构中保存了 "),e("code",[_._v("B-Tree")]),_._v(" 索引(技术上来说是 "),e("code",[_._v("B+Tree")]),_._v(")和数据行。")]),_._v(" "),e("h4",{attrs:{id:"_5-非聚簇索引"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-非聚簇索引"}},[_._v("#")]),_._v(" (5) 非聚簇索引")]),_._v(" "),e("p",[_._v("不是聚簇索引，就是非聚簇索引")]),_._v(" "),e("h3",{attrs:{id:"_3、基础语法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3、基础语法"}},[_._v("#")]),_._v(" 3、基础语法")]),_._v(" "),e("ul",[e("li",[_._v("查看索引")])]),_._v(" "),e("p",[_._v("SHOW INDEX FROM table_name")]),_._v(" "),e("ul",[e("li",[_._v("创建索引")])]),_._v(" "),e("p",[_._v("CREATE [UNIQUE] INDEX indexName ON mytable(columnname(length));")]),_._v(" "),e("p",[_._v("ALTER TABLE 表名 ADD [UNIQUE] INDEX [indexName] ON (columnname(length))")]),_._v(" "),e("ul",[e("li",[_._v("删除索引")])]),_._v(" "),e("p",[_._v("DROP INDEX [indexName] ON mytable;")]),_._v(" "),e("h2",{attrs:{id:"二、执行计划"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、执行计划"}},[_._v("#")]),_._v(" 二、执行计划")]),_._v(" "),e("h3",{attrs:{id:"_1、什么是执行计划"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、什么是执行计划"}},[_._v("#")]),_._v(" 1、什么是执行计划")]),_._v(" "),e("p",[_._v("使用 "),e("code",[_._v("EXPLAIN")]),_._v(" 关键字可以模拟优化器执行 "),e("code",[_._v("SQL")]),_._v(" 查询语句，从而知道 "),e("code",[_._v("MySQL")]),_._v(" 是如何处理你的 "),e("code",[_._v("SQL")]),_._v(" 语句的。分析你的查询语句或是表结构的性能瓶颈。")]),_._v(" "),e("h3",{attrs:{id:"_2、执行计划的作用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、执行计划的作用"}},[_._v("#")]),_._v(" 2、执行计划的作用")]),_._v(" "),e("ul",[e("li",[_._v("表的读取顺序")]),_._v(" "),e("li",[_._v("数据读取操作的操作类型")]),_._v(" "),e("li",[_._v("哪些索引可以使用")]),_._v(" "),e("li",[_._v("哪些索引被实际使用")]),_._v(" "),e("li",[_._v("表之间的引用")]),_._v(" "),e("li",[_._v("每张表有多少行被优化器查询")])]),_._v(" "),e("h3",{attrs:{id:"_3、执行计划的语法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3、执行计划的语法"}},[_._v("#")]),_._v(" 3、执行计划的语法")]),_._v(" "),e("p",[_._v("执行计划的语法其实非常简单： 在 "),e("code",[_._v("SQL")]),_._v(" 查询的前面加上 "),e("code",[_._v("EXPLAIN")]),_._v(" 关键字就行。")]),_._v(" "),e("p",[_._v("比如："),e("code",[_._v("EXPLAIN select * from table1")])]),_._v(" "),e("p",[_._v("** 重点的就是 "),e("code",[_._v("EXPLAIN")]),_._v(" 后面你要分析的 "),e("code",[_._v("SQL")]),_._v(" 语句 **")]),_._v(" "),e("h3",{attrs:{id:"_4、执行计划详解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4、执行计划详解"}},[_._v("#")]),_._v(" 4、执行计划详解")]),_._v(" "),e("p",[_._v("通过 "),e("code",[_._v("EXPLAIN")]),_._v(" 关键分析的结果由以下列组成，接下来挨个分析每一个列")]),_._v(" "),e("p",[_._v("| id | select_type | table | positions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |")]),_._v(" "),e("h4",{attrs:{id:"_1-id"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-id"}},[_._v("#")]),_._v(" (1) id")]),_._v(" "),e("p",[_._v("描述 "),e("code",[_._v("select")]),_._v(" 查询的序列号,包含一组数字，表示查询中执行 "),e("code",[_._v("select")]),_._v(" 子句或操作表的顺序，根据 "),e("code",[_._v("id")]),_._v(" 的数值结果可以分成一下三种情况：")]),_._v(" "),e("ul",[e("li",[_._v("id 相同")])]),_._v(" "),e("p",[_._v("执行顺序由上至下")]),_._v(" "),e("ul",[e("li",[_._v("id 不同")])]),_._v(" "),e("p",[_._v("如果是子查询，"),e("code",[_._v("id")]),_._v(" 的序号会递增，"),e("code",[_._v("id")]),_._v(" 值越大优先级越高，越先被执行")]),_._v(" "),e("ul",[e("li",[_._v("id 相同不同")])]),_._v(" "),e("p",[_._v("先按照 "),e("code",[_._v("id")]),_._v(" 不同的由大到小执行，"),e("code",[_._v("id")]),_._v(" 相同的由上至下")]),_._v(" "),e("h4",{attrs:{id:"_2-select-type"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-select-type"}},[_._v("#")]),_._v(" (2) select_type")]),_._v(" "),e("p",[_._v("查询的类型，用于区别：普通查询、联合查询、子查询等的复杂查询，类型如下：")]),_._v(" "),e("table",[e("thead",[e("tr",[e("th",[_._v("类型")]),_._v(" "),e("th",[_._v("描述")])])]),_._v(" "),e("tbody",[e("tr",[e("td",[_._v("SIMPLE")]),_._v(" "),e("td",[_._v("简单的 "),e("code",[_._v("select")]),_._v(" 查询,查询中不包含子查询或者 "),e("code",[_._v("UNION")])])]),_._v(" "),e("tr",[e("td",[_._v("PRIMARY")]),_._v(" "),e("td",[_._v("查询中若包含任何复杂的子部分，最外层查询则被标记为")])]),_._v(" "),e("tr",[e("td",[_._v("SUBQUERY")]),_._v(" "),e("td",[_._v("在 "),e("code",[_._v("SELECT")]),_._v(" 或 "),e("code",[_._v("WHERE")]),_._v(" 列表中包含了子查询")])]),_._v(" "),e("tr",[e("td",[_._v("DERIVED")]),_._v(" "),e("td",[_._v("在 "),e("code",[_._v("FROM")]),_._v(" 列表中包含的子查询被标记为 "),e("code",[_._v("DERIVED")]),_._v(" (衍生) "),e("code",[_._v("MySQL")]),_._v(" 会递归执行这些子查询, 把结果放在临时表里。")])]),_._v(" "),e("tr",[e("td",[_._v("UNION")]),_._v(" "),e("td",[_._v("若第二个 "),e("code",[_._v("SELECT")]),_._v(" 出现在 "),e("code",[_._v("UNION")]),_._v(" 之后，则被标记为 "),e("code",[_._v("UNION")]),_._v("； 若 "),e("code",[_._v("UNION")]),_._v(" 包含在 "),e("code",[_._v("FROM")]),_._v(" 子句的子查询中,外层 "),e("code",[_._v("SELECT")]),_._v(" 将被标记为："),e("code",[_._v("DERIVED")])])]),_._v(" "),e("tr",[e("td",[_._v("UNION RESULT")]),_._v(" "),e("td",[_._v("从 "),e("code",[_._v("UNION")]),_._v(" 表获取结果的 "),e("code",[_._v("SELECT")])])])])]),_._v(" "),e("h4",{attrs:{id:"_3-table"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-table"}},[_._v("#")]),_._v(" (3) table")]),_._v(" "),e("p",[_._v("显示这一行的数据是关于哪张表的")]),_._v(" "),e("h4",{attrs:{id:"_4-type"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-type"}},[_._v("#")]),_._v(" (4) type")]),_._v(" "),e("p",[e("code",[_._v("type")]),_._v(" 显示的是访问类型，是较为重要的一个指标，结果值从最好到最坏依次是：")]),_._v(" "),e("p",[e("code",[_._v("system")]),_._v(" > "),e("code",[_._v("const")]),_._v(" > "),e("code",[_._v("eq_ref")]),_._v(" > "),e("code",[_._v("ref")]),_._v(" > "),e("code",[_._v("fulltext")]),_._v(" > "),e("code",[_._v("ref_or_null")]),_._v(" > "),e("code",[_._v("index_merge")]),_._v(" > "),e("code",[_._v("unique_subquery")]),_._v(" > "),e("code",[_._v("index_subquery")]),_._v(" > "),e("code",[_._v("range")]),_._v(" > "),e("code",[_._v("index")]),_._v(" > "),e("code",[_._v("ALL")])]),_._v(" "),e("p",[_._v("比较重要的，需要记忆的：")]),_._v(" "),e("p",[e("code",[_._v("system")]),_._v(" > "),e("code",[_._v("const")]),_._v(" > "),e("code",[_._v("eq_ref")]),_._v(" > "),e("code",[_._v("ref")]),_._v(" > "),e("code",[_._v("range")]),_._v(" > "),e("code",[_._v("index")]),_._v(" > "),e("code",[_._v("ALL")]),_._v(" 一般来说，得保证查询至少达到 "),e("code",[_._v("range")]),_._v(" 级别，最好能达到 "),e("code",[_._v("ref。")])]),_._v(" "),e("h5",{attrs:{id:"system-与-const"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#system-与-const"}},[_._v("#")]),_._v(" system 与 const")]),_._v(" "),e("ul",[e("li",[_._v("system")])]),_._v(" "),e("p",[_._v("表只有一行记录（等于系统表），这是 "),e("code",[_._v("const")]),_._v(" 类型的特列，平时不会出现，这个也可以忽略不计")]),_._v(" "),e("ul",[e("li",[_._v("const")])]),_._v(" "),e("p",[_._v("表示通过索引一次就找到了")]),_._v(" "),e("p",[e("code",[_._v("const")]),_._v(" 用于比较 "),e("code",[_._v("primary key")]),_._v(" 或者 "),e("code",[_._v("unique")]),_._v(" 索引。因为只匹配一行数据，所以很快。如将主键置于 "),e("code",[_._v("where")]),_._v(" 列表中，"),e("code",[_._v("MySQL")]),_._v(" 就能将该查询转换为一个常量。")]),_._v(" "),e("h5",{attrs:{id:"eq-ref"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#eq-ref"}},[_._v("#")]),_._v(" eq_ref")]),_._v(" "),e("p",[_._v("唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。")]),_._v(" "),e("h5",{attrs:{id:"ref"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ref"}},[_._v("#")]),_._v(" ref")]),_._v(" "),e("p",[_._v("非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体")]),_._v(" "),e("h5",{attrs:{id:"range"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#range"}},[_._v("#")]),_._v(" range")]),_._v(" "),e("p",[_._v("只检索给定范围的行,使用一个索引来选择行。"),e("code",[_._v("key")]),_._v(" 列显示使用了哪个索引。")]),_._v(" "),e("p",[_._v("一般就是在你的 "),e("code",[_._v("where")]),_._v(" 语句中出现了 "),e("code",[_._v("between")]),_._v("、"),e("code",[_._v("<")]),_._v("、"),e("code",[_._v(">")]),_._v("、"),e("code",[_._v("in")]),_._v(" 等的查询。")]),_._v(" "),e("p",[_._v("这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引。")]),_._v(" "),e("h5",{attrs:{id:"index"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#index"}},[_._v("#")]),_._v(" index")]),_._v(" "),e("p",[_._v("当查询的结果全为索引列的时候，虽然也是全部扫描，但是只查询的索引库，而没有去查询数据。")]),_._v(" "),e("h5",{attrs:{id:"all"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#all"}},[_._v("#")]),_._v(" all")]),_._v(" "),e("p",[e("code",[_._v("Full Table Scan")]),_._v("，将遍历全表以找到匹配的行")]),_._v(" "),e("h4",{attrs:{id:"_5-possible-keys-与-key"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-possible-keys-与-key"}},[_._v("#")]),_._v(" (5) possible_keys 与 Key")]),_._v(" "),e("ul",[e("li",[_._v("possible_keys")])]),_._v(" "),e("p",[_._v("可能使用的索引")]),_._v(" "),e("ul",[e("li",[_._v("key")])]),_._v(" "),e("p",[_._v("实际使用的索引。如果为 "),e("code",[_._v("NULL")]),_._v("，则没有使用索引")]),_._v(" "),e("p",[_._v("查询中若使用了覆盖索引，则该索引和查询的 "),e("code",[_._v("select")]),_._v(" 字段重叠")]),_._v(" "),e("h4",{attrs:{id:"_6-key-len"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-key-len"}},[_._v("#")]),_._v(" (6) key_len")]),_._v(" "),e("p",[e("code",[_._v("key_len")]),_._v(" 表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好")]),_._v(" "),e("p",[e("code",[_._v("key_len")]),_._v(" 显示的值为索引字段的最大可能长度，并非实际使用长度，即 "),e("code",[_._v("key_len")]),_._v(" 是根据表定义计算而得，不是通过表内检索出的")]),_._v(" "),e("p",[_._v("充分用了索引的 "),e("code",[_._v("key_len")]),_._v(" 比没有充分用到索引的 "),e("code",[_._v("key_len")]),_._v(" 要大。")]),_._v(" "),e("ul",[e("li",[e("code",[_._v("key_len")]),_._v(" 表示索引使用的字节数，")]),_._v(" "),e("li",[_._v("根据这个值，就可以判断索引使用情况，特别是在组合索引的时候，判断所有的索引字段是否都被查询用到。")]),_._v(" "),e("li",[e("code",[_._v("char")]),_._v(" 和 "),e("code",[_._v("varchar")]),_._v(" 跟字符编码也有密切的联系,")]),_._v(" "),e("li",[e("code",[_._v("latin1")]),_._v(" 占用 1 个字节，"),e("code",[_._v("gbk")]),_._v(" 占用 2 个字节，"),e("code",[_._v("utf8")]),_._v(" 占用 3 个字节。（不同字符编码占用的存储空间不同）")])]),_._v(" "),e("p",[_._v("对于 "),e("code",[_._v("char")]),_._v(" 和 "),e("code",[_._v("varchar")]),_._v(" 类型的计算：")]),_._v(" "),e("ul",[e("li",[_._v("允许为 "),e("code",[_._v("null")]),_._v(" 会使 "),e("code",[_._v("key_len")]),_._v(" 的计算加1")]),_._v(" "),e("li",[e("code",[_._v("varchar")]),_._v(" 会使 "),e("code",[_._v("key_len")]),_._v(" 的计算加2")])]),_._v(" "),e("p",[_._v("对于数值类型的计算：")]),_._v(" "),e("p",[_._v("按照类型本身所占有的字节数来计算，如果允许 "),e("code",[_._v("null")]),_._v(" 再加1")]),_._v(" "),e("h4",{attrs:{id:"_7-ref"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-ref"}},[_._v("#")]),_._v(" (7) ref")]),_._v(" "),e("p",[_._v("显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值")]),_._v(" "),e("h4",{attrs:{id:"_8-rows"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8-rows"}},[_._v("#")]),_._v(" (8) rows")]),_._v(" "),e("p",[_._v("根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数")]),_._v(" "),e("h4",{attrs:{id:"_9-extra"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_9-extra"}},[_._v("#")]),_._v(" (9) extra")]),_._v(" "),e("p",[_._v("包含不适合在其他列中显示但十分重要的额外信息。")]),_._v(" "),e("table",[e("thead",[e("tr",[e("th",[_._v("值")]),_._v(" "),e("th",[_._v("描述")])])]),_._v(" "),e("tbody",[e("tr",[e("td",[_._v("using filesort")]),_._v(" "),e("td",[_._v("说明 "),e("code",[_._v("MySQL")]),_._v(" 会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。"),e("br"),e("code",[_._v("MySQL")]),_._v(" 中无法利用索引完成的排序操作称为“文件排序”")])]),_._v(" "),e("tr",[e("td",[_._v("using temporary")]),_._v(" "),e("td",[_._v("使用了临时表保存中间结果，"),e("code",[_._v("MySQL")]),_._v(" 在对查询结果排序时使用临时表。常见于排序 "),e("code",[_._v("order by")]),_._v(" 和分组查询 "),e("code",[_._v("group by")]),_._v("。")])]),_._v(" "),e("tr",[e("td",[_._v("using index")]),_._v(" "),e("td",[_._v("是否用了覆盖索引")])]),_._v(" "),e("tr",[e("td",[_._v("using where")]),_._v(" "),e("td",[_._v("使用了 "),e("code",[_._v("where")]),_._v(" 过滤")])]),_._v(" "),e("tr",[e("td",[_._v("using join buffer")]),_._v(" "),e("td",[_._v("使用了连接缓存")])]),_._v(" "),e("tr",[e("td",[_._v("impossible where")]),_._v(" "),e("td",[e("code",[_._v("where")]),_._v(" 字句的值总是 "),e("code",[_._v("false")]),_._v("，不能用来获取任何元祖")])])])]),_._v(" "),e("Valine")],1)}),[],!1,null,null,null);v.default=a.exports}}]);