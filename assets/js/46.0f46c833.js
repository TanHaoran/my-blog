(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{254:function(v,_,a){"use strict";a.r(_);var e=a(0),s=Object(e.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"虚拟机的前世今生和java内存区域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#虚拟机的前世今生和java内存区域"}},[v._v("#")]),v._v(" 虚拟机的前世今生和Java内存区域")]),v._v(" "),a("Counter",{attrs:{path:"enjoy3",name:"虚拟机的前世今生和Java内存区域"}}),v._v(" "),a("h2",{attrs:{id:"一、jvm-基础知识"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、jvm-基础知识"}},[v._v("#")]),v._v(" 一、JVM 基础知识")]),v._v(" "),a("h3",{attrs:{id:"_1、jvm-从编译到执行"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、jvm-从编译到执行"}},[v._v("#")]),v._v(" 1、JVM 从编译到执行")]),v._v(" "),a("h4",{attrs:{id:"_1-java-程序的执行过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-java-程序的执行过程"}},[v._v("#")]),v._v(" (1) Java 程序的执行过程")]),v._v(" "),a("p",[v._v("一个 "),a("code",[v._v("Java")]),v._v(" 程序，首先经过 "),a("code",[v._v("javac")]),v._v(" 编译成 "),a("code",[v._v(".class")]),v._v(" 文件，然后 "),a("code",[v._v("JVM")]),v._v(" 将其加载到方法区，执行引擎将会执行这些字节码。执行时，会翻译成操作系统相关的函数。"),a("code",[v._v("JVM")]),v._v(" 作为 "),a("code",[v._v(".class")]),v._v(" 文件的翻译存在，输入字节码，调用操作系统函数。")]),v._v(" "),a("p",[v._v("过程如下： "),a("code",[v._v("Java")]),v._v(" 文件 -> 编译器 -> 字节码 -> "),a("code",[v._v("JVM")]),v._v(" -> 机器码。\n"),a("code",[v._v("JVM")]),v._v(" 全称 "),a("code",[v._v("Java Virtual Machine")]),v._v("，也就是我们耳熟能详的 "),a("code",[v._v("Java 虚拟机")]),v._v("。它能识别 "),a("code",[v._v(".class")]),v._v(" 后缀的文件，并且能够解析它的指令，最终调用操作系统上的函数，完成我们想要的操作。")]),v._v(" "),a("h4",{attrs:{id:"_2-jvm、jre、jdk-的关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-jvm、jre、jdk-的关系"}},[v._v("#")]),v._v(" (2) JVM、JRE、JDK 的关系")]),v._v(" "),a("p",[a("code",[v._v("JVM")]),v._v(" 只是一个翻译，把 "),a("code",[v._v("class")]),v._v(" 翻译成机器识别的代码，但是需要注意，"),a("code",[v._v("JVM")]),v._v(" 不会自己生成代码，需要大家编写代码，同时需要很多依赖类库，这个时候就需要用到 "),a("code",[v._v("JRE")]),v._v("。")]),v._v(" "),a("p",[a("code",[v._v("JRE")]),v._v(" 是什么，它除了包含 "),a("code",[v._v("JVM")]),v._v(" 之外，提供了很多的类库（就是我们说的 "),a("code",[v._v("jar")]),v._v(" 包，它可以提供一些即插即用的功能，比如读取或者操作文件，连接网络，使用 "),a("code",[v._v("I/O")]),v._v(" 等等之类的）这些东西就是 "),a("code",[v._v("JRE")]),v._v(" 提供的基础类库。"),a("code",[v._v("JVM")]),v._v(" 标准加上实现的一大堆基础类库，就组成了 "),a("code",[v._v("Java")]),v._v(" 的运行时环境，也就是我们常说的 "),a("code",[v._v("JRE")]),v._v("（"),a("code",[v._v("Java Runtime Environment")]),v._v("）。")]),v._v(" "),a("p",[v._v("但对于程序员来说，"),a("code",[v._v("JRE")]),v._v(" 还不够。我写完要编译代码，还需要调试代码，还需要打包代码、有时候还需要反编译代码。所以我们会使用 "),a("code",[v._v("JDK")]),v._v("，因为 "),a("code",[v._v("JDK")]),v._v(" 还提供了一些非常好用的小工具，比如 "),a("code",[v._v("javac")]),v._v("（编译代码）、"),a("code",[v._v("java")]),v._v("、"),a("code",[v._v("jar")]),v._v(" （打包代码）、"),a("code",[v._v("javap")]),v._v("（反编译<反汇编>）等。这个就是 "),a("code",[v._v("JDK")]),v._v("。")]),v._v(" "),a("p",[v._v("具体可以文档可以通过官网去下载："),a("a",{attrs:{href:"https://www.oracle.com/java/technologies/javase-jdk8-doc-downloads.html",target:"_blank",rel:"noopener noreferrer"}},[v._v("https://www.oracle.com/java/technologies/javase-jdk8-doc-downloads.html"),a("OutboundLink")],1)]),v._v(" "),a("p",[a("code",[v._v("JVM")]),v._v(" 的作用是：从软件层面屏蔽不同操作系统在底层硬件和指令的不同。这个就是我们在宏观方面对"),a("code",[v._v("JVM")]),v._v(" 的一个认识。")]),v._v(" "),a("p",[v._v("同时 "),a("code",[v._v("JVM")]),v._v(" 是一个虚拟化的操作系统，类似于 "),a("code",[v._v("Linux")]),v._v(" 或者 "),a("code",[v._v("Windows")]),v._v(" 的操作系统，只是它架在操作系统上，接收字节码也就是 "),a("code",[v._v("class")]),v._v("，把字节码翻译成操作系统上的机器码且进行执行。")]),v._v(" "),a("h3",{attrs:{id:"_2、从跨平台到跨语言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、从跨平台到跨语言"}},[v._v("#")]),v._v(" 2、从跨平台到跨语言")]),v._v(" "),a("ul",[a("li",[v._v("跨平台")])]),v._v(" "),a("p",[v._v("我们写的一个类，在不同的操作系统上（"),a("code",[v._v("Linux")]),v._v("、"),a("code",[v._v("Windows")]),v._v("、"),a("code",[v._v("MacOS")]),v._v(" 等平台）执行，效果是一样，这个就是 "),a("code",[v._v("JVM")]),v._v(" 的跨平台性。")]),v._v(" "),a("p",[v._v("为了实现跨平台型，不同操作系统有对应的 "),a("code",[v._v("JDK")]),v._v(" 的版本：")]),v._v(" "),a("p",[a("a",{attrs:{href:"https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html",target:"_blank",rel:"noopener noreferrer"}},[v._v("https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html"),a("OutboundLink")],1)]),v._v(" "),a("ul",[a("li",[v._v("跨语言（语言无关性）")])]),v._v(" "),a("p",[a("code",[v._v("JVM")]),v._v(" 只识别字节码，所以 "),a("code",[v._v("JVM")]),v._v(" 其实跟语言是解耦的，也就是没有直接关联，"),a("code",[v._v("JVM")]),v._v(" 运行不是翻译 "),a("code",[v._v("Java")]),v._v(" 文件，而是识别 "),a("code",[v._v("class")]),v._v(" 文件，这个一般称之为字节码。还有像 "),a("code",[v._v("Groovy")]),v._v("、"),a("code",[v._v("Kotlin")]),v._v("、"),a("code",[v._v("Scala")]),v._v(" 等等语言，它们其实也是编译成字节码，所以它们也可以在 "),a("code",[v._v("JVM")]),v._v(" 上面跑，这个就是 "),a("code",[v._v("JVM")]),v._v(" 的跨语言特征。"),a("code",[v._v("Java")]),v._v(" 的跨语言性一定程度上奠定了非常强大的 "),a("code",[v._v("Java")]),v._v(" 语言生态圈。")]),v._v(" "),a("h3",{attrs:{id:"_3、jvm-的发展"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、jvm-的发展"}},[v._v("#")]),v._v(" 3、JVM 的发展")]),v._v(" "),a("h4",{attrs:{id:"常见的-jvm-实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常见的-jvm-实现"}},[v._v("#")]),v._v(" 常见的 JVM 实现")]),v._v(" "),a("ul",[a("li",[v._v("Hotspot")])]),v._v(" "),a("p",[v._v("目前使用的最多的 "),a("code",[v._v("JVM")]),v._v("。在命令行输入 "),a("code",[v._v("java –version")]),v._v("。它会输出你现在使用的虚拟机的名字、版本等信息、执行模式。")]),v._v(" "),a("p",[v._v("我的信息如下：")]),v._v(" "),a("div",{staticClass:"language-cmd line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[v._v('java version "1.8.0_191"\nJava(TM) SE Runtime Environment (build 1.8.0_191-b12)\nJava HotSpot(TM) 64-Bit Server VM (build 25.191-b12, mixed mode)\n')])]),v._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[v._v("1")]),a("br"),a("span",{staticClass:"line-number"},[v._v("2")]),a("br"),a("span",{staticClass:"line-number"},[v._v("3")]),a("br")])]),a("ul",[a("li",[v._v("Jrocket")])]),v._v(" "),a("p",[v._v("原来属于 "),a("code",[v._v("BEA")]),v._v(" 公司，曾号称世界上最快的 "),a("code",[v._v("JVM")]),v._v("，后被 "),a("code",[v._v("Oracle")]),v._v(" 公司收购，合并于 "),a("code",[v._v("Hotspot")]),v._v("。")]),v._v(" "),a("ul",[a("li",[v._v("J9")])]),v._v(" "),a("p",[a("code",[v._v("IBM")]),v._v(" 有自己的 "),a("code",[v._v("JVM")]),v._v(" 实现，它的名字叫做 "),a("code",[v._v("J9")]),v._v("。 主要是用在 "),a("code",[v._v("IBM")]),v._v(" 产品（"),a("code",[v._v("IBM WebSphere")]),v._v(" 和 "),a("code",[v._v("IBM")]),v._v(" 的 "),a("code",[v._v("AIX")]),v._v(" 平台上）")]),v._v(" "),a("ul",[a("li",[v._v("TaobaoVM")])]),v._v(" "),a("p",[v._v("只有一定体量、一定规模的厂商才会开发自己的虚拟机，比如淘宝有自己的 "),a("code",[v._v("JVM")]),v._v(",它实际上是 "),a("code",[v._v("Hotspot")]),v._v(" 的定制版，专门为淘宝准备的，阿里、天猫都是用的这款虚拟机。")]),v._v(" "),a("ul",[a("li",[v._v("LiquidVM")])]),v._v(" "),a("p",[v._v("它是一个针对硬件的虚拟机，它下面是没有操作系统的（不是 "),a("code",[v._v("Linux")]),v._v(" 也不是 "),a("code",[v._v("windows")]),v._v("）,下面直接就是硬件，运行效率比较高。")]),v._v(" "),a("ul",[a("li",[v._v("zing")])]),v._v(" "),a("p",[v._v("它属于 "),a("code",[v._v("zual")]),v._v(" 这家公司，非常牛，是一个商业产品，很贵！它的垃圾回收速度非常快（1 毫秒之内），是业界标杆。它的一个垃圾回收的算法后来被 "),a("code",[v._v("Hotspot")]),v._v(" 吸收才有了现在的 "),a("code",[v._v("ZGC")]),v._v("。")]),v._v(" "),a("h2",{attrs:{id:"二、jvm-整体知识模块"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、jvm-整体知识模块"}},[v._v("#")]),v._v(" 二、JVM 整体知识模块")]),v._v(" "),a("p",[a("code",[v._v("JVM")]),v._v(" 能涉及非常庞大的一块知识体系，比如内存结构、垃圾回收、类加载、性能调优、"),a("code",[v._v("JVM")]),v._v(" 自身优化技术、执行引擎、类文件结构、监控工具等。")]),v._v(" "),a("p",[v._v("但是在所有的知识体系中，都或多或少跟内存结构有一定的关系：比如垃圾回收回收的就是内存、类加载加载到的地方也是内存、性能优化也涉及到内存优化、执行引擎与内存密不可分、类文件结构与内存的设计有关系，监控工具也会监控内存。所以内存结构处于 "),a("code",[v._v("JVM")]),v._v(" 中核心位置。也是属于我们入门 "),a("code",[v._v("JVM")]),v._v(" 学习的最好的选择。")]),v._v(" "),a("p",[v._v("同时 "),a("code",[v._v("JVM")]),v._v(" 是一个虚拟化的操作系统，所以除了要虚拟指令之外，最重要的一个事情就是需要虚拟化内存，这个虚拟化内存就是 "),a("code",[v._v("JVM")]),v._v(" 的内存区域。")]),v._v(" "),a("h3",{attrs:{id:"_1、jvm-的内存区域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、jvm-的内存区域"}},[v._v("#")]),v._v(" 1、JVM 的内存区域")]),v._v(" "),a("h4",{attrs:{id:"_1-运行时数据区域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-运行时数据区域"}},[v._v("#")]),v._v(" (1) 运行时数据区域")]),v._v(" "),a("ul",[a("li",[v._v("运行时数据区的定义")])]),v._v(" "),a("p",[a("code",[v._v("JVM")]),v._v(" 在执行 "),a("code",[v._v("Java")]),v._v(" 程序的过程中会把它所管理的内存划分为若干个不同的数据区域")]),v._v(" "),a("p",[a("code",[v._v("Java")]),v._v(" 引以为豪的就是它的自动内存管理机制。相比于 "),a("code",[v._v("C++")]),v._v(" 的手动内存管理、复杂难以理解的指针等，"),a("code",[v._v("Java")]),v._v(" 程序写起来就方便的多。")]),v._v(" "),a("p",[v._v("所以要深入理解 "),a("code",[v._v("JVM")]),v._v(" 必须理解内存虚拟化的概念。")]),v._v(" "),a("p",[v._v("在 "),a("code",[v._v("JVM")]),v._v(" 中，"),a("code",[v._v("JVM")]),v._v(" 内存主要分为 "),a("code",[v._v("堆")]),v._v("、"),a("code",[v._v("方法区")]),v._v("、"),a("code",[v._v("虚拟机栈")]),v._v("、"),a("code",[v._v("程序计数器")]),v._v(" 和 "),a("code",[v._v("本地方法栈")]),v._v(" 等。")]),v._v(" "),a("p",[v._v("同时按照与线程的关系也可以这么划分区域：")]),v._v(" "),a("p",[a("code",[v._v("线程私有区域")]),v._v("：一个线程拥有单独的一份内存区域。")]),v._v(" "),a("p",[a("code",[v._v("线程共享区域")]),v._v("：被所有线程共享，且只有一份。")]),v._v(" "),a("p",[a("code",[v._v("直接内存")]),v._v("：这个虽然不是运行时数据区的一部分，但是会被频繁使用。你可以理解成没有被虚拟机化的操作系统上的其他内存（比如操作系统上有 8G 内存，被 "),a("code",[v._v("JVM")]),v._v(" 虚拟化了 3G，那么还剩余 5G， "),a("code",[v._v("JVM")]),v._v(" 是借助一些工具使用这 5G 内存的，这个内存部分称之为直接内存）")]),v._v(" "),a("p",[a("img",{attrs:{src:"https://yjtravel-public.oss-cn-beijing.aliyuncs.com/my-blog/enjoy3/jvm1.png",alt:"内存划分"}})]),v._v(" "),a("h4",{attrs:{id:"_2-java-方法的运行与虚拟机栈"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-java-方法的运行与虚拟机栈"}},[v._v("#")]),v._v(" (2) JAVA 方法的运行与虚拟机栈")]),v._v(" "),a("p",[a("code",[v._v("虚拟机栈")]),v._v(" 是线程运行 "),a("code",[v._v("Java 方法")]),v._v(" 所需的数据、指令、返回地址。其实在我们实际的代码中，一个线程是可以运行多个方法的。例如这段方法：")]),v._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("public")]),v._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("class")]),v._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("MethodAndStack")]),v._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("public")]),v._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("static")]),v._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("void")]),v._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[v._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("String")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("]")]),v._v(" args"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v("\n        "),a("span",{pre:!0,attrs:{class:"token function"}},[v._v("a")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),v._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("public")]),v._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("static")]),v._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("void")]),v._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[v._v("a")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v("\n        "),a("span",{pre:!0,attrs:{class:"token function"}},[v._v("b")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),v._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("public")]),v._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("static")]),v._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("void")]),v._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[v._v("b")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v("\n        "),a("span",{pre:!0,attrs:{class:"token function"}},[v._v("c")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),v._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("public")]),v._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("static")]),v._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("void")]),v._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[v._v("c")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),v._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),v._v("\n")])]),v._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[v._v("1")]),a("br"),a("span",{staticClass:"line-number"},[v._v("2")]),a("br"),a("span",{staticClass:"line-number"},[v._v("3")]),a("br"),a("span",{staticClass:"line-number"},[v._v("4")]),a("br"),a("span",{staticClass:"line-number"},[v._v("5")]),a("br"),a("span",{staticClass:"line-number"},[v._v("6")]),a("br"),a("span",{staticClass:"line-number"},[v._v("7")]),a("br"),a("span",{staticClass:"line-number"},[v._v("8")]),a("br"),a("span",{staticClass:"line-number"},[v._v("9")]),a("br"),a("span",{staticClass:"line-number"},[v._v("10")]),a("br"),a("span",{staticClass:"line-number"},[v._v("11")]),a("br"),a("span",{staticClass:"line-number"},[v._v("12")]),a("br"),a("span",{staticClass:"line-number"},[v._v("13")]),a("br"),a("span",{staticClass:"line-number"},[v._v("14")]),a("br")])]),a("p",[v._v("这段代码很简单，就是起一个 "),a("code",[v._v("main()")]),v._v(" 方法，在 "),a("code",[v._v("main()")]),v._v(" 方法运行中调用 "),a("code",[v._v("a()")]),v._v(" 方法，"),a("code",[v._v("a()")]),v._v(" 方法中调用 "),a("code",[v._v("b()")]),v._v(" 方法，"),a("code",[v._v("b()")]),v._v(" 方法中运行 "),a("code",[v._v("c()")]),v._v(" 方法。")]),v._v(" "),a("p",[v._v("把代码跑起来，"),a("code",[v._v("线程1")]),v._v(" 来运行这段代码， "),a("code",[v._v("线程1")]),v._v(" 跑起来，就会有一个对应的 "),a("code",[v._v("虚拟机栈")]),v._v("，同时在执行每个方法的时候都会打包成一个 "),a("code",[v._v("栈帧")]),v._v("。")]),v._v(" "),a("p",[v._v("比如 "),a("code",[v._v("main()")]),v._v(" 开始运行，打包一个 "),a("code",[v._v("栈帧")]),v._v(" 送入到 "),a("code",[v._v("虚拟机栈")]),v._v("，然后 "),a("code",[v._v("a()")]),v._v(" 方法入栈，接着 "),a("code",[v._v("b()")]),v._v(" 方法入栈，最后 "),a("code",[v._v("c()")]),v._v(" 方法入栈。"),a("code",[v._v("c()")]),v._v(" 方法运行完了，"),a("code",[v._v("c()")]),v._v(" 方法出栈，接着 "),a("code",[v._v("b()")]),v._v(" 方法运行完了，"),a("code",[v._v("b()")]),v._v(" 方法出栈、接着 "),a("code",[v._v("a()")]),v._v(" 方法运行完了，"),a("code",[v._v("a()")]),v._v(" 方法出栈，最后 "),a("code",[v._v("main()")]),v._v(" 方法运行完了，"),a("code",[v._v("main()")]),v._v(" 方法这个 "),a("code",[v._v("栈帧")]),v._v(" 就出栈了。")]),v._v(" "),a("p",[v._v("这个就是 "),a("code",[v._v("Java 方法")]),v._v(" 运行对 "),a("code",[v._v("虚拟机栈")]),v._v(" 的一个影响。"),a("code",[v._v("虚拟机栈")]),v._v(" 就是用来存储线程运行方法中的数据的。而每一个方法对应一个 "),a("code",[v._v("栈帧")]),v._v("。")]),v._v(" "),a("h3",{attrs:{id:"_2、运行时数据区及-jvm-的整体内存结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、运行时数据区及-jvm-的整体内存结构"}},[v._v("#")]),v._v(" 2、运行时数据区及 JVM 的整体内存结构")]),v._v(" "),a("h4",{attrs:{id:"_1-虚拟机栈"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-虚拟机栈"}},[v._v("#")]),v._v(" (1) 虚拟机栈")]),v._v(" "),a("ul",[a("li",[v._v("栈的数据结构")])]),v._v(" "),a("p",[v._v("先进后出("),a("code",[v._v("FILO")]),v._v(")的数据结构")]),v._v(" "),a("ul",[a("li",[v._v("虚拟机栈的作用")])]),v._v(" "),a("p",[v._v("在 "),a("code",[v._v("JVM")]),v._v(" 运行过程中存储当前线程运行方法所需的数据、指令、返回地址。")]),v._v(" "),a("ul",[a("li",[v._v("虚拟机栈是基于线程的")])]),v._v(" "),a("p",[v._v("哪怕你只有一个 "),a("code",[v._v("main()")]),v._v(" 方法，也是以线程的方式运行的。在线程的生命周期中，参与计算的数据会频繁地入栈和出栈，栈的生命周期是和线程一样的。")]),v._v(" "),a("ul",[a("li",[v._v("虚拟机栈的大小")])]),v._v(" "),a("p",[v._v("缺省为 1M，可用参数 "),a("code",[v._v("–Xss")]),v._v(" 调整大小，例如 "),a("code",[v._v("-Xss256k")]),v._v("。参数官方文档（"),a("code",[v._v("JDK1.8")]),v._v("）："),a("a",{attrs:{href:"https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html",target:"_blank",rel:"noopener noreferrer"}},[v._v("https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html"),a("OutboundLink")],1)]),v._v(" "),a("h5",{attrs:{id:"xss-大小"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#xss-大小"}},[v._v("#")]),v._v(" -Xss 大小")]),v._v(" "),a("p",[v._v("设置线程堆栈大小（以字节码为单位）。附加字母 "),a("code",[v._v("k")]),v._v(" 或 "),a("code",[v._v("K")]),v._v(" 表示 "),a("code",[v._v("KB")]),v._v("，"),a("code",[v._v("m")]),v._v(" 或 "),a("code",[v._v("M")]),v._v(" 表示 "),a("code",[v._v("MB")]),v._v("，"),a("code",[v._v("g")]),v._v(" 或 "),a("code",[v._v("G")]),v._v(" 表示 "),a("code",[v._v("GB")]),v._v("。默认值取决于平台。")]),v._v(" "),a("ul",[a("li",[v._v("Linux / ARM（32位）：320KB")]),v._v(" "),a("li",[v._v("Linux / i386（32位）：320KB")]),v._v(" "),a("li",[v._v("Linux / x64（64位）：1024KB")]),v._v(" "),a("li",[v._v("OS X （64位）：1024KB")]),v._v(" "),a("li",[v._v("Oracle Solaris / i386（32位）：320KB")]),v._v(" "),a("li",[v._v("Oracle Solaris / x64位（64位）：1024KB")])]),v._v(" "),a("h5",{attrs:{id:"栈帧"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#栈帧"}},[v._v("#")]),v._v(" 栈帧")]),v._v(" "),a("p",[v._v("在每个 "),a("code",[v._v("Java 方法")]),v._v(" 被调用的时候，都会创建一个 "),a("code",[v._v("栈帧")]),v._v("，并入栈。一旦方法完成相应的调用，则出栈。")]),v._v(" "),a("p",[a("code",[v._v("栈帧")]),v._v(" 大体都包含四个区域：("),a("code",[v._v("局部变量表")]),v._v("、"),a("code",[v._v("操作数栈")]),v._v("、"),a("code",[v._v("动态连接")]),v._v("、"),a("code",[v._v("返回地址")]),v._v(")")]),v._v(" "),a("ul",[a("li",[v._v("局部变量表")])]),v._v(" "),a("p",[v._v("顾名思义就是局部变量的表，用于存放局部变量（方法中的变量）。首先它是一个 32位 的长度，主要存放 "),a("code",[v._v("Java")]),v._v(" 的 "),a("code",[v._v("八大基础数据类型")]),v._v("，一般 32位 就可以存放下，如果是 64位 的就使用高低位占用两个也可以存放下，如果是局部的一些对象，比如 "),a("code",[v._v("Object")]),v._v(" 对象，我们只需要存放它的一个引用地址即可。")]),v._v(" "),a("ul",[a("li",[v._v("操作数栈")])]),v._v(" "),a("p",[v._v("存放 "),a("code",[v._v("Java 方法")]),v._v(" 执行的操作数的，它就是一个栈，先进后出的栈结构，操作数栈，就是用来操作的，操作的的元素可以是任意的 "),a("code",[v._v("Java 数据类型")]),v._v("，所以一个方法刚刚开始的时候，这个方法的操作数栈就是空的。")]),v._v(" "),a("p",[v._v("操作数栈本质上是 "),a("code",[v._v("JVM")]),v._v(" 执行引擎的一个工作区，也就是方法在执行，才会对操作数栈进行操作，如果代码不不执行，操作数栈其实就是空的。")]),v._v(" "),a("ul",[a("li",[v._v("动态连接")])]),v._v(" "),a("p",[a("code",[v._v("Java")]),v._v(" 语言特性多态，后续会结合 "),a("code",[v._v("class")]),v._v(" 与 "),a("code",[v._v("执行引擎")]),v._v(" 一起详细说明。")]),v._v(" "),a("ul",[a("li",[v._v("返回地址")])]),v._v(" "),a("p",[v._v("正常返回：调用程序计数器中的地址作为返回；异常：通过异常处理器表（非栈帧中的）来确定")]),v._v(" "),a("p",[v._v("同时，"),a("code",[v._v("虚拟机栈")]),v._v(" 这个内存也不是无限大，它有大小限制，默认情况下是 1M。")]),v._v(" "),a("p",[v._v("我们不断的往 "),a("code",[v._v("虚拟机栈")]),v._v(" 中入 "),a("code",[v._v("栈帧")]),v._v("，但是就是不出栈的话，那么这个虚拟机栈就会爆掉。")]),v._v(" "),a("p",[v._v("例如下面这段代码就会发生栈溢出：")]),v._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("public")]),v._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("class")]),v._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("StackError")]),v._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("public")]),v._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("static")]),v._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("void")]),v._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[v._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("String")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("]")]),v._v(" args"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v("\n        "),a("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("A")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),v._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("public")]),v._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("static")]),v._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("void")]),v._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("A")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v("\n        "),a("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("A")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),v._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),v._v("\n")])]),v._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[v._v("1")]),a("br"),a("span",{staticClass:"line-number"},[v._v("2")]),a("br"),a("span",{staticClass:"line-number"},[v._v("3")]),a("br"),a("span",{staticClass:"line-number"},[v._v("4")]),a("br"),a("span",{staticClass:"line-number"},[v._v("5")]),a("br"),a("span",{staticClass:"line-number"},[v._v("6")]),a("br"),a("span",{staticClass:"line-number"},[v._v("7")]),a("br"),a("span",{staticClass:"line-number"},[v._v("8")]),a("br")])]),a("div",{staticClass:"language-console line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[v._v('Exception in thread "main" java.lang.StackOverflowError\n')])]),v._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[v._v("1")]),a("br")])]),a("h4",{attrs:{id:"_2-程序计数器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-程序计数器"}},[v._v("#")]),v._v(" (2) 程序计数器")]),v._v(" "),a("p",[v._v("较小的内存空间，当前线程执行的字节码的行号指示器；各线程之间独立存储，互不影响。")]),v._v(" "),a("p",[v._v("程序计数器是一块很小的内存空间，主要用来记录各个线程执行的字节码的地址，例如，分支、循环、跳转、异常、线程恢复等都依赖于计数器。")]),v._v(" "),a("p",[v._v("由于 "),a("code",[v._v("Java")]),v._v(" 是多线程语言，当执行的线程数量超过 "),a("code",[v._v("CPU")]),v._v(" 核数时，线程之间会根据时间片轮询争夺 "),a("code",[v._v("CPU")]),v._v(" 资源。如果一个线程的时间片用完了，或者是其它原因导致这个线程的 "),a("code",[v._v("CPU")]),v._v(" 资源被提前抢夺，那么这个退出的线程就需要单独的一个程序计数器，来记录下一条运行的指令。")]),v._v(" "),a("p",[v._v("因为 "),a("code",[v._v("JVM")]),v._v(" 内部有完整的指令与执行的一套流程，所以在运行 "),a("code",[v._v("Java 方法")]),v._v(" 的时候需要使用 "),a("code",[v._v("程序计数器")]),v._v(" （记录字节码执行的地址或行号），如果是遇到本地方法（"),a("code",[v._v("native 方法")]),v._v("），这个方法不是 "),a("code",[v._v("JVM")]),v._v(" 来具体执行，所以此时 "),a("code",[v._v("程序计数器")]),v._v(" 不需要记录，这个是因为在操作系统层面也有一个 "),a("code",[v._v("程序计数器")]),v._v("，这个会记录本地代码的执行的地址，所以在执行 "),a("code",[v._v("native 方法")]),v._v(" 时，"),a("code",[v._v("JVM")]),v._v(" 中程序计数器的值为空("),a("code",[v._v("Undefined")]),v._v(")。")]),v._v(" "),a("p",[v._v("另外程序计数器也是 "),a("code",[v._v("JVM")]),v._v(" 中唯一不会 "),a("code",[v._v("OOM")]),v._v("("),a("code",[v._v("OutOfMemory")]),v._v(")的内存区域。")]),v._v(" "),a("h5",{attrs:{id:"栈帧执行对内存区域的影响"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#栈帧执行对内存区域的影响"}},[v._v("#")]),v._v(" 栈帧执行对内存区域的影响")]),v._v(" "),a("p",[v._v("对 "),a("code",[v._v("class")]),v._v(" 进行反汇编 "),a("code",[v._v("javap –c XXXX.class")]),v._v("。")]),v._v(" "),a("p",[v._v("字节码助记码解释地址："),a("a",{attrs:{href:"https://cloud.tencent.com/developer/article/1333540",target:"_blank",rel:"noopener noreferrer"}},[v._v("https://cloud.tencent.com/developer/article/1333540"),a("OutboundLink")],1)]),v._v(" "),a("p",[v._v("一个线程中的虚拟机栈和程序计数器：")]),v._v(" "),a("p",[a("img",{attrs:{src:"https://yjtravel-public.oss-cn-beijing.aliyuncs.com/my-blog/enjoy3/jvm2.png",alt:"一个线程中的虚拟机栈和程序计数器"}})]),v._v(" "),a("p",[v._v("在 "),a("code",[v._v("JVM")]),v._v(" 中，基于解释执行的这种方式是基于栈的引擎，这个说的栈，就是操作数栈。")]),v._v(" "),a("h4",{attrs:{id:"_3-本地方法栈"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-本地方法栈"}},[v._v("#")]),v._v(" (3) 本地方法栈")]),v._v(" "),a("p",[v._v("本地方法栈跟 "),a("code",[v._v("Java 虚拟机栈")]),v._v(" 的功能类似，"),a("code",[v._v("Java 虚拟机栈")]),v._v(" 用于管理 "),a("code",[v._v("Java 函数")]),v._v(" 的调用，而本地方法栈则用于管理 "),a("code",[v._v("本地方法")]),v._v(" 的调用。但本地方法并不是用 "),a("code",[v._v("Java")]),v._v(" 实现的，而是由 "),a("code",[v._v("C")]),v._v(" 语言实现的(比如 "),a("code",[v._v("Object")]),v._v(" 的 "),a("code",[v._v("hashcode()")]),v._v(" 方法)。")]),v._v(" "),a("p",[v._v("本地方法栈是和虚拟机栈非常相似的一个区域，它服务的对象是 "),a("code",[v._v("native 方法")]),v._v("。你甚至可以认为虚拟机栈和本地方法栈是同一个区域。")]),v._v(" "),a("p",[v._v("虚拟机规范无强制规定，各版本虚拟机自由实现，"),a("code",[v._v("HotSpot")]),v._v(" 直接把 "),a("code",[v._v("本地方法栈")]),v._v(" 和 "),a("code",[v._v("虚拟机栈")]),v._v(" 合二为一。")]),v._v(" "),a("h4",{attrs:{id:"_4-方法区"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-方法区"}},[v._v("#")]),v._v(" (4) 方法区")]),v._v(" "),a("p",[v._v("方法区主要是用来存放已被虚拟机加载的类相关信息，包括类信息、静态变量、常量、运行时常量池、字符串常量池等。")]),v._v(" "),a("p",[v._v("方法区是 "),a("code",[v._v("JVM")]),v._v(" 对内存的“逻辑划分”，在 "),a("code",[v._v("JDK1.7")]),v._v(" 及之前很多开发者都习惯将 "),a("code",[v._v("方法区")]),v._v(" 称为 "),a("code",[v._v("永久代")]),v._v(" ，是因为在 "),a("code",[v._v("HotSpot")]),v._v(" 虚拟机中，设计人员使用了 "),a("code",[v._v("永久代")]),v._v(" 来实现了 "),a("code",[v._v("JVM")]),v._v(" 规范的 "),a("code",[v._v("方法区")]),v._v("。在 "),a("code",[v._v("JDK1.8")]),v._v(" 及以后使用了 "),a("code",[v._v("元空间")]),v._v(" 来实现方法区。")]),v._v(" "),a("p",[a("code",[v._v("JVM")]),v._v(" 在执行某个类的时候，必须先加载。在加载类（加载、验证、准备、解析、初始化）的时候，"),a("code",[v._v("JVM")]),v._v(" 会先加载 "),a("code",[v._v("class")]),v._v(" 文件，而在 "),a("code",[v._v("class")]),v._v(" 文件中除了有类的版本、字段、方法和接口等描述信息外，还有一项信息是 "),a("code",[v._v("常量池")]),v._v("("),a("code",[v._v("Constant Pool Table")]),v._v(")，用于存放编译期间生成的各种 "),a("code",[v._v("字面量")]),v._v(" 和 "),a("code",[v._v("符号引用")]),v._v("。")]),v._v(" "),a("h5",{attrs:{id:"字面量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#字面量"}},[v._v("#")]),v._v(" 字面量")]),v._v(" "),a("p",[a("code",[v._v("字面量")]),v._v(" 包括字符串（"),a("code",[v._v('String a = "b"')]),v._v("）、基本类型的常量（"),a("code",[v._v("final")]),v._v(" 修饰的变量），"),a("code",[v._v("符号引用")]),v._v(" 则包括类和方法的全限定名（例如 "),a("code",[v._v("String")]),v._v(" 这个类，它的全限定名就是 "),a("code",[v._v("Java.lang.String")]),v._v("）、字段的名称和描述符以及方法的名称和描述符。")]),v._v(" "),a("h5",{attrs:{id:"符号引用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#符号引用"}},[v._v("#")]),v._v(" 符号引用")]),v._v(" "),a("p",[v._v("一个 "),a("code",[v._v("Java 类")]),v._v("（假设为 "),a("code",[v._v("People")]),v._v(" 类）被编译成一个 "),a("code",[v._v("class")]),v._v(" 文件时，如果 "),a("code",[v._v("People")]),v._v(" 类引用了 "),a("code",[v._v("Tool")]),v._v(" 类，但是在编译时 "),a("code",[v._v("People")]),v._v(" 类并不知道引用类的实际内存地址，因此只能使用符号引用来代替。")]),v._v(" "),a("p",[v._v("而在类装载器装载 "),a("code",[v._v("People")]),v._v(" 类时，此时可以通过虚拟机获取 "),a("code",[v._v("Tool")]),v._v(" 类的实际内存地址，因此便可以将符号 "),a("code",[v._v("org.simple.Tool")]),v._v(" 替换为 "),a("code",[v._v("Tool")]),v._v(" 类的实际内存地址，及直接引用地址。")]),v._v(" "),a("p",[v._v("即在编译时用 "),a("code",[v._v("符号引用")]),v._v(" 来代替 "),a("code",[v._v("引用类")]),v._v("，在加载时再通过虚拟机获取该引用类的实际地址。")]),v._v(" "),a("p",[v._v("以一组符号来描述所引用的目标，符号可以是任何形式的 "),a("code",[v._v("字面量")]),v._v("，只要使用时能无歧义地定位到目标即可。"),a("code",[v._v("符号引用")]),v._v(" 与虚拟机实现的内存布局是无关的，引用的目标不一定已经加载到内存中。")]),v._v(" "),a("h5",{attrs:{id:"常量池与运行时常量池"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常量池与运行时常量池"}},[v._v("#")]),v._v(" 常量池与运行时常量池")]),v._v(" "),a("p",[v._v("而当类加载到内存中后，"),a("code",[v._v("JVM")]),v._v(" 就会将 "),a("code",[v._v("class")]),v._v(" 文件 "),a("code",[v._v("常量池")]),v._v(" 中的内容存放到 "),a("code",[v._v("运行时的常量池")]),v._v(" 中；在解析阶段，"),a("code",[v._v("JVM")]),v._v(" 会把 "),a("code",[v._v("符号引用")]),v._v(" 替换为 "),a("code",[v._v("直接引用")]),v._v("（对象的索引值）。")]),v._v(" "),a("p",[v._v("例如，类中的一个字符串常量在 "),a("code",[v._v("class")]),v._v(" 文件中时，存放在 "),a("code",[v._v("class")]),v._v(" 文件 "),a("code",[v._v("常量池")]),v._v(" 中的；在 "),a("code",[v._v("JVM")]),v._v(" 加载完类之后，"),a("code",[v._v("JVM")]),v._v(" 会将这个字符串常量放到 "),a("code",[v._v("运行时常量池")]),v._v(" 中，并在解析阶段，指定该字符串对象的索引值。运行时常量池是全局共享的，多个类共用一个运行时常量池，"),a("code",[v._v("class")]),v._v(" 文件中 "),a("code",[v._v("常量池")]),v._v(" 多个相同的字符串在运行时常量池只会存在一份。")]),v._v(" "),a("p",[a("code",[v._v("常量池")]),v._v(" 有很多概念，包括 "),a("code",[v._v("运行时常量池")]),v._v("、"),a("code",[v._v("class 常量池")]),v._v("、"),a("code",[v._v("字符串常量池")]),v._v("。")]),v._v(" "),a("p",[v._v("虚拟机规范只规定以上区域属于 "),a("code",[v._v("方法区")]),v._v("，并没有规定虚拟机厂商的实现。")]),v._v(" "),a("p",[v._v("严格来说是 "),a("code",[v._v("静态常量池")]),v._v(" 和 "),a("code",[v._v("运行时常量池")]),v._v("，"),a("code",[v._v("静态常量池")]),v._v(" 是存放字符串 "),a("code",[v._v("字面量")]),v._v("、"),a("code",[v._v("符号引用")]),v._v(" 以及 类和方法的信息，而运行时常量池存放的是运行时一些 "),a("code",[v._v("直接引用")]),v._v("。")]),v._v(" "),a("p",[a("code",[v._v("运行时常量池")]),v._v(" 是在类加载完成之后，将 "),a("code",[v._v("静态常量池")]),v._v(" 中的 "),a("code",[v._v("符号引用")]),v._v(" 值转存到 "),a("code",[v._v("运行时常量池")]),v._v(" 中，类在解析之后，将"),a("code",[v._v("符号引用")]),v._v(" 替换成 "),a("code",[v._v("直接引用")]),v._v("。")]),v._v(" "),a("p",[v._v("运行时常量池在 "),a("code",[v._v("JDK1.7")]),v._v(" 版本之后，就移到 "),a("code",[v._v("堆")]),v._v(" 内存中了，这里指的是物理空间，而逻辑上还是属于 "),a("code",[v._v("方法区")]),v._v("（方法区是逻辑分区）。")]),v._v(" "),a("h5",{attrs:{id:"元空间"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#元空间"}},[v._v("#")]),v._v(" 元空间")]),v._v(" "),a("p",[a("code",[v._v("方法区")]),v._v(" 与 "),a("code",[v._v("堆")]),v._v(" 空间类似，也是一个共享内存区，所以 "),a("code",[v._v("方法区")]),v._v(" 是线程共享的。假如两个线程都试图访问 "),a("code",[v._v("方法区")]),v._v(" 中的同一个类信息，而这个类还没有装入 "),a("code",[v._v("JVM")]),v._v("，那么此时就只允许一个线程去加载它，另一个线程必须等待。")]),v._v(" "),a("p",[v._v("在 "),a("code",[v._v("HotSpot")]),v._v(" 虚拟机、"),a("code",[v._v("Java7")]),v._v(" 版本中已经将永久代的 "),a("code",[v._v("静态变量")]),v._v(" 和 "),a("code",[v._v("运行时常量池")]),v._v(" 转移到了 "),a("code",[v._v("堆")]),v._v(" 中，其余部分则存储在 "),a("code",[v._v("JVM")]),v._v(" 的非堆内存中，而 "),a("code",[v._v("Java8")]),v._v(" 版本已经将 "),a("code",[v._v("方法区")]),v._v(" 中实现的 "),a("code",[v._v("永久代")]),v._v(" 去掉了，并用"),a("code",[v._v("元空间")]),v._v("（"),a("code",[v._v("class metadata")]),v._v("）代替了之前的 "),a("code",[v._v("永久代")]),v._v("，并且 "),a("code",[v._v("元空间")]),v._v(" 的存储位置是本地内存。")]),v._v(" "),a("p",[v._v("设置元空间大小参数：")]),v._v(" "),a("ul",[a("li",[v._v("jdk1.7 及以前（初始和最大值）：-XX:PermSize；-XX:MaxPermSize；")]),v._v(" "),a("li",[v._v("jdk1.8 以后（初始和最大值）：-XX:MetaspaceSize； -XX:MaxMetaspaceSize")]),v._v(" "),a("li",[v._v("jdk1.8 以后大小就只受本机总内存的限制（如果不设置参数的话）")])]),v._v(" "),a("p",[a("code",[v._v("JVM")]),v._v(" 参数参考："),a("a",{attrs:{href:"https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html",target:"_blank",rel:"noopener noreferrer"}},[v._v("https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html"),a("OutboundLink")],1)]),v._v(" "),a("p",[a("code",[v._v("Java8")]),v._v(" 为什么使用元空间替代永久代，这样做有什么好处呢？")]),v._v(" "),a("p",[v._v("官方给出的解释是：")]),v._v(" "),a("p",[v._v("移除 "),a("code",[v._v("永久代")]),v._v(" 是为了融合 "),a("code",[v._v("HotSpot JVM")]),v._v(" 与 "),a("code",[v._v("JRockit VM")]),v._v(" 而做出的努力，因为 "),a("code",[v._v("JRockit")]),v._v(" 没有永久代，所以不需要配置永久代\n。"),a("code",[v._v("永久代")]),v._v(" 内存经常不够用或发生内存溢出，抛出异常 "),a("code",[v._v("java.lang.OutOfMemoryError: PermGen")]),v._v("。这是因为在 "),a("code",[v._v("JDK1.7")]),v._v(" 版本中，指定的 "),a("code",[v._v("PermGen")]),v._v(" 区大小为 8M，由于 "),a("code",[v._v("PermGen")]),v._v(" 中类的元数据信息在每次 "),a("code",[v._v("FullGC")]),v._v(" 的时候都可能被收集，回收率都偏低，成绩很难令人满意；还有为 "),a("code",[v._v("PermGen")]),v._v(" 分配多大的空间很难确定，"),a("code",[v._v("PermSize")]),v._v(" 的大小依赖于很多因素，比如，"),a("code",[v._v("JVM")]),v._v(" 加载的 "),a("code",[v._v("class")]),v._v(" 总数、"),a("code",[v._v("常量池")]),v._v(" 的大小和方法的大小等。")]),v._v(" "),a("h4",{attrs:{id:"_5-堆"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-堆"}},[v._v("#")]),v._v(" (5) 堆")]),v._v(" "),a("p",[v._v("堆是 "),a("code",[v._v("JVM")]),v._v(" 上最大的内存区域，我们申请的几乎所有的对象，都是在这里存储的。我们常说的垃圾回收，操作的对象就是堆。")]),v._v(" "),a("p",[v._v("堆空间一般是程序启动时，就申请了，但是并不一定会全部使用。堆一般设置成可伸缩的。")]),v._v(" "),a("p",[v._v("随着对象的频繁创建，堆空间占用的越来越多，就需要不定期的对不再使用的对象进行回收。这个在 "),a("code",[v._v("Java")]),v._v(" 中，就叫作 "),a("code",[v._v("GC")]),v._v("（"),a("code",[v._v("Garbage Collection")]),v._v("）。")]),v._v(" "),a("p",[v._v("那一个对象创建的时候，到底是在堆上分配，还是在栈上分配呢？这和两个方面有关：对象的类型和在 "),a("code",[v._v("Java")]),v._v(" 类中存在的位置。")]),v._v(" "),a("p",[a("code",[v._v("Java")]),v._v(" 的对象可以分为 "),a("code",[v._v("基本数据类型")]),v._v(" 和 "),a("code",[v._v("普通对象")]),v._v("。")]),v._v(" "),a("p",[v._v("对于普通对象来说，"),a("code",[v._v("JVM")]),v._v(" 会首先在堆上创建对象，然后在其他地方使用的其实是它的引用。比如，把这个引用保存在虚拟机栈的局部变量表中。")]),v._v(" "),a("p",[v._v("对于基本数据类型来说（"),a("code",[v._v("byte")]),v._v("、"),a("code",[v._v("short")]),v._v("、"),a("code",[v._v("int")]),v._v("、"),a("code",[v._v("long")]),v._v("、"),a("code",[v._v("float")]),v._v("、"),a("code",[v._v("double")]),v._v("、"),a("code",[v._v("char")]),v._v(")，有两种情况。")]),v._v(" "),a("p",[v._v("当你在方法体内声明了基本数据类型的对象，它就会在栈上直接分配。其他情况，都是在堆上分配。")]),v._v(" "),a("p",[v._v("设置堆大小参数：")]),v._v(" "),a("ul",[a("li",[v._v("-Xms：堆的最小值；")]),v._v(" "),a("li",[v._v("-Xmx：堆的最大值；")]),v._v(" "),a("li",[v._v("-Xmn：新生代的大小；")]),v._v(" "),a("li",[v._v("-XX:NewSize；新生代最小值；")]),v._v(" "),a("li",[v._v("-XX:MaxNewSize：新生代最大值；")])]),v._v(" "),a("p",[v._v("例如 "),a("code",[v._v("-Xmx256m")]),v._v(" ，设置堆最大值为 256m")]),v._v(" "),a("h4",{attrs:{id:"_6-直接内存（堆外内存）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-直接内存（堆外内存）"}},[v._v("#")]),v._v(" (6) 直接内存（堆外内存）")]),v._v(" "),a("p",[v._v("直接内存有一种更加科学的叫法，"),a("code",[v._v("堆外内存")]),v._v("。")]),v._v(" "),a("p",[a("code",[v._v("JVM")]),v._v(" 在运行时，会从操作系统申请大块的堆内存，进行数据的存储；同时还有虚拟机栈、本地方法栈和程序计数器，这块称之为栈区。操作系统剩余的内存也就是堆外内存。")]),v._v(" "),a("p",[v._v("它不是虚拟机运行时数据区的一部分，也不是 "),a("code",[v._v("JVM")]),v._v(" 规范中定义的内存区域；如果使用了 "),a("code",[v._v("NIO")]),v._v("，这块区域会被频繁使用，在 "),a("code",[v._v("Java 堆")]),v._v(" 内可以用 "),a("code",[v._v("DirectByteBuffer")]),v._v(" 对象直接引用并操作。")]),v._v(" "),a("p",[v._v("这块内存不受 "),a("code",[v._v("Java 堆")]),v._v(" 大小限制，但受本机总内存的限制，可以通过 "),a("code",[v._v("-XX:MaxDirectMemorySize")]),v._v(" 来设置（默认与堆内存最大值一样），所以也会出现 "),a("code",[v._v("OOM")]),v._v(" 异常。")]),v._v(" "),a("p",[v._v("总结下：")]),v._v(" "),a("ol",[a("li",[v._v("直接内存主要是通过 "),a("code",[v._v("DirectByteBuffer")]),v._v(" 申请的内存，可以使用参数 "),a("code",[v._v("MaxDirectMemorySize")]),v._v(" 来限制它的大小。")]),v._v(" "),a("li",[v._v("其他堆外内存，主要是指使用了 "),a("code",[v._v("Unsafe")]),v._v(" 或者其他 "),a("code",[v._v("JNI")]),v._v(" 手段直接直接申请的内存。堆外内存的泄漏是非常严重的，它的排查难度高、影响大，甚至会造成主机的死亡。同时，要注意 "),a("code",[v._v("Oracle")]),v._v(" 之前计划在 "),a("code",[v._v("Java 9")]),v._v(" 中去掉 "),a("code",[v._v("sun.misc.Unsafe")]),v._v(" 的 "),a("code",[v._v("API")]),v._v("。这里删除 "),a("code",[v._v("sun.misc.Unsafe")]),v._v(" 的原因之一是使 "),a("code",[v._v("Java")]),v._v(" 更加安全，并且有替代方案。目前主要针对的 "),a("code",[v._v("JDK1.8")]),v._v("，"),a("code",[v._v("JDK1.9")]),v._v(" 暂时不放入讨论范围中，大致知道 "),a("code",[v._v("Java")]),v._v(" 的发展即可。")])]),v._v(" "),a("Valine")],1)}),[],!1,null,null,null);_.default=s.exports}}]);